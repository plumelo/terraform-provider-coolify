// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ApplicationBuildPack.
const (
	ApplicationBuildPackDockercompose ApplicationBuildPack = "dockercompose"
	ApplicationBuildPackDockerfile    ApplicationBuildPack = "dockerfile"
	ApplicationBuildPackNixpacks      ApplicationBuildPack = "nixpacks"
	ApplicationBuildPackStatic        ApplicationBuildPack = "static"
)

// Defines values for ApplicationRedirect.
const (
	ApplicationRedirectBoth   ApplicationRedirect = "both"
	ApplicationRedirectNonWww ApplicationRedirect = "non-www"
	ApplicationRedirectWww    ApplicationRedirect = "www"
)

// Defines values for ServerProxyType.
const (
	ServerProxyTypeCaddy   ServerProxyType = "caddy"
	ServerProxyTypeNone    ServerProxyType = "none"
	ServerProxyTypeTraefik ServerProxyType = "traefik"
)

// Defines values for CreateDockerfileApplicationJSONBodyBuildPack.
const (
	CreateDockerfileApplicationJSONBodyBuildPackDockercompose CreateDockerfileApplicationJSONBodyBuildPack = "dockercompose"
	CreateDockerfileApplicationJSONBodyBuildPackDockerfile    CreateDockerfileApplicationJSONBodyBuildPack = "dockerfile"
	CreateDockerfileApplicationJSONBodyBuildPackNixpacks      CreateDockerfileApplicationJSONBodyBuildPack = "nixpacks"
	CreateDockerfileApplicationJSONBodyBuildPackStatic        CreateDockerfileApplicationJSONBodyBuildPack = "static"
)

// Defines values for CreateDockerfileApplicationJSONBodyRedirect.
const (
	CreateDockerfileApplicationJSONBodyRedirectBoth   CreateDockerfileApplicationJSONBodyRedirect = "both"
	CreateDockerfileApplicationJSONBodyRedirectNonWww CreateDockerfileApplicationJSONBodyRedirect = "non-www"
	CreateDockerfileApplicationJSONBodyRedirectWww    CreateDockerfileApplicationJSONBodyRedirect = "www"
)

// Defines values for CreateDockerimageApplicationJSONBodyRedirect.
const (
	CreateDockerimageApplicationJSONBodyRedirectBoth   CreateDockerimageApplicationJSONBodyRedirect = "both"
	CreateDockerimageApplicationJSONBodyRedirectNonWww CreateDockerimageApplicationJSONBodyRedirect = "non-www"
	CreateDockerimageApplicationJSONBodyRedirectWww    CreateDockerimageApplicationJSONBodyRedirect = "www"
)

// Defines values for CreatePrivateDeployKeyApplicationJSONBodyBuildPack.
const (
	CreatePrivateDeployKeyApplicationJSONBodyBuildPackDockercompose CreatePrivateDeployKeyApplicationJSONBodyBuildPack = "dockercompose"
	CreatePrivateDeployKeyApplicationJSONBodyBuildPackDockerfile    CreatePrivateDeployKeyApplicationJSONBodyBuildPack = "dockerfile"
	CreatePrivateDeployKeyApplicationJSONBodyBuildPackNixpacks      CreatePrivateDeployKeyApplicationJSONBodyBuildPack = "nixpacks"
	CreatePrivateDeployKeyApplicationJSONBodyBuildPackStatic        CreatePrivateDeployKeyApplicationJSONBodyBuildPack = "static"
)

// Defines values for CreatePrivateDeployKeyApplicationJSONBodyRedirect.
const (
	CreatePrivateDeployKeyApplicationJSONBodyRedirectBoth   CreatePrivateDeployKeyApplicationJSONBodyRedirect = "both"
	CreatePrivateDeployKeyApplicationJSONBodyRedirectNonWww CreatePrivateDeployKeyApplicationJSONBodyRedirect = "non-www"
	CreatePrivateDeployKeyApplicationJSONBodyRedirectWww    CreatePrivateDeployKeyApplicationJSONBodyRedirect = "www"
)

// Defines values for CreatePrivateDeployKeyApplicationJSONBodyStaticImage.
const (
	CreatePrivateDeployKeyApplicationJSONBodyStaticImageNginxAlpine CreatePrivateDeployKeyApplicationJSONBodyStaticImage = "nginx:alpine"
)

// Defines values for CreatePrivateGithubAppApplicationJSONBodyBuildPack.
const (
	CreatePrivateGithubAppApplicationJSONBodyBuildPackDockercompose CreatePrivateGithubAppApplicationJSONBodyBuildPack = "dockercompose"
	CreatePrivateGithubAppApplicationJSONBodyBuildPackDockerfile    CreatePrivateGithubAppApplicationJSONBodyBuildPack = "dockerfile"
	CreatePrivateGithubAppApplicationJSONBodyBuildPackNixpacks      CreatePrivateGithubAppApplicationJSONBodyBuildPack = "nixpacks"
	CreatePrivateGithubAppApplicationJSONBodyBuildPackStatic        CreatePrivateGithubAppApplicationJSONBodyBuildPack = "static"
)

// Defines values for CreatePrivateGithubAppApplicationJSONBodyRedirect.
const (
	CreatePrivateGithubAppApplicationJSONBodyRedirectBoth   CreatePrivateGithubAppApplicationJSONBodyRedirect = "both"
	CreatePrivateGithubAppApplicationJSONBodyRedirectNonWww CreatePrivateGithubAppApplicationJSONBodyRedirect = "non-www"
	CreatePrivateGithubAppApplicationJSONBodyRedirectWww    CreatePrivateGithubAppApplicationJSONBodyRedirect = "www"
)

// Defines values for CreatePrivateGithubAppApplicationJSONBodyStaticImage.
const (
	CreatePrivateGithubAppApplicationJSONBodyStaticImageNginxAlpine CreatePrivateGithubAppApplicationJSONBodyStaticImage = "nginx:alpine"
)

// Defines values for CreatePublicApplicationJSONBodyBuildPack.
const (
	CreatePublicApplicationJSONBodyBuildPackDockercompose CreatePublicApplicationJSONBodyBuildPack = "dockercompose"
	CreatePublicApplicationJSONBodyBuildPackDockerfile    CreatePublicApplicationJSONBodyBuildPack = "dockerfile"
	CreatePublicApplicationJSONBodyBuildPackNixpacks      CreatePublicApplicationJSONBodyBuildPack = "nixpacks"
	CreatePublicApplicationJSONBodyBuildPackStatic        CreatePublicApplicationJSONBodyBuildPack = "static"
)

// Defines values for CreatePublicApplicationJSONBodyRedirect.
const (
	CreatePublicApplicationJSONBodyRedirectBoth   CreatePublicApplicationJSONBodyRedirect = "both"
	CreatePublicApplicationJSONBodyRedirectNonWww CreatePublicApplicationJSONBodyRedirect = "non-www"
	CreatePublicApplicationJSONBodyRedirectWww    CreatePublicApplicationJSONBodyRedirect = "www"
)

// Defines values for CreatePublicApplicationJSONBodyStaticImage.
const (
	NginxAlpine CreatePublicApplicationJSONBodyStaticImage = "nginx:alpine"
)

// Defines values for UpdateApplicationByUuidJSONBodyBuildPack.
const (
	UpdateApplicationByUuidJSONBodyBuildPackDockercompose UpdateApplicationByUuidJSONBodyBuildPack = "dockercompose"
	UpdateApplicationByUuidJSONBodyBuildPackDockerfile    UpdateApplicationByUuidJSONBodyBuildPack = "dockerfile"
	UpdateApplicationByUuidJSONBodyBuildPackNixpacks      UpdateApplicationByUuidJSONBodyBuildPack = "nixpacks"
	UpdateApplicationByUuidJSONBodyBuildPackStatic        UpdateApplicationByUuidJSONBodyBuildPack = "static"
)

// Defines values for UpdateApplicationByUuidJSONBodyRedirect.
const (
	Both   UpdateApplicationByUuidJSONBodyRedirect = "both"
	NonWww UpdateApplicationByUuidJSONBodyRedirect = "non-www"
	Www    UpdateApplicationByUuidJSONBodyRedirect = "www"
)

// Defines values for CreateServerJSONBodyProxyType.
const (
	CreateServerJSONBodyProxyTypeCaddy   CreateServerJSONBodyProxyType = "caddy"
	CreateServerJSONBodyProxyTypeNone    CreateServerJSONBodyProxyType = "none"
	CreateServerJSONBodyProxyTypeTraefik CreateServerJSONBodyProxyType = "traefik"
)

// Defines values for UpdateServerByUuidJSONBodyProxyType.
const (
	Caddy   UpdateServerByUuidJSONBodyProxyType = "caddy"
	None    UpdateServerByUuidJSONBodyProxyType = "none"
	Traefik UpdateServerByUuidJSONBodyProxyType = "traefik"
)

// Defines values for CreateServiceJSONBodyType.
const (
	Activepieces                CreateServiceJSONBodyType = "activepieces"
	Appsmith                    CreateServiceJSONBodyType = "appsmith"
	Appwrite                    CreateServiceJSONBodyType = "appwrite"
	Authentik                   CreateServiceJSONBodyType = "authentik"
	Babybuddy                   CreateServiceJSONBodyType = "babybuddy"
	Budge                       CreateServiceJSONBodyType = "budge"
	Changedetection             CreateServiceJSONBodyType = "changedetection"
	Chatwoot                    CreateServiceJSONBodyType = "chatwoot"
	ClassicpressWithMariadb     CreateServiceJSONBodyType = "classicpress-with-mariadb"
	ClassicpressWithMysql       CreateServiceJSONBodyType = "classicpress-with-mysql"
	ClassicpressWithoutDatabase CreateServiceJSONBodyType = "classicpress-without-database"
	Cloudflared                 CreateServiceJSONBodyType = "cloudflared"
	CodeServer                  CreateServiceJSONBodyType = "code-server"
	Dashboard                   CreateServiceJSONBodyType = "dashboard"
	Directus                    CreateServiceJSONBodyType = "directus"
	DirectusWithPostgresql      CreateServiceJSONBodyType = "directus-with-postgresql"
	DockerRegistry              CreateServiceJSONBodyType = "docker-registry"
	Docuseal                    CreateServiceJSONBodyType = "docuseal"
	DocusealWithPostgres        CreateServiceJSONBodyType = "docuseal-with-postgres"
	Dokuwiki                    CreateServiceJSONBodyType = "dokuwiki"
	Duplicati                   CreateServiceJSONBodyType = "duplicati"
	Emby                        CreateServiceJSONBodyType = "emby"
	Embystat                    CreateServiceJSONBodyType = "embystat"
	Fider                       CreateServiceJSONBodyType = "fider"
	Filebrowser                 CreateServiceJSONBodyType = "filebrowser"
	Firefly                     CreateServiceJSONBodyType = "firefly"
	Formbricks                  CreateServiceJSONBodyType = "formbricks"
	Ghost                       CreateServiceJSONBodyType = "ghost"
	Gitea                       CreateServiceJSONBodyType = "gitea"
	GiteaWithMariadb            CreateServiceJSONBodyType = "gitea-with-mariadb"
	GiteaWithMysql              CreateServiceJSONBodyType = "gitea-with-mysql"
	GiteaWithPostgresql         CreateServiceJSONBodyType = "gitea-with-postgresql"
	Glance                      CreateServiceJSONBodyType = "glance"
	Glances                     CreateServiceJSONBodyType = "glances"
	Glitchtip                   CreateServiceJSONBodyType = "glitchtip"
	Grafana                     CreateServiceJSONBodyType = "grafana"
	GrafanaWithPostgresql       CreateServiceJSONBodyType = "grafana-with-postgresql"
	Grocy                       CreateServiceJSONBodyType = "grocy"
	Heimdall                    CreateServiceJSONBodyType = "heimdall"
	Homepage                    CreateServiceJSONBodyType = "homepage"
	Jellyfin                    CreateServiceJSONBodyType = "jellyfin"
	Kuzzle                      CreateServiceJSONBodyType = "kuzzle"
	Listmonk                    CreateServiceJSONBodyType = "listmonk"
	Logto                       CreateServiceJSONBodyType = "logto"
	Mediawiki                   CreateServiceJSONBodyType = "mediawiki"
	Meilisearch                 CreateServiceJSONBodyType = "meilisearch"
	Metabase                    CreateServiceJSONBodyType = "metabase"
	Metube                      CreateServiceJSONBodyType = "metube"
	Minio                       CreateServiceJSONBodyType = "minio"
	Moodle                      CreateServiceJSONBodyType = "moodle"
	N8n                         CreateServiceJSONBodyType = "n8n"
	N8nWithPostgresql           CreateServiceJSONBodyType = "n8n-with-postgresql"
	NextImageTransformation     CreateServiceJSONBodyType = "next-image-transformation"
	Nextcloud                   CreateServiceJSONBodyType = "nextcloud"
	Nocodb                      CreateServiceJSONBodyType = "nocodb"
	Odoo                        CreateServiceJSONBodyType = "odoo"
	Openblocks                  CreateServiceJSONBodyType = "openblocks"
	Pairdrop                    CreateServiceJSONBodyType = "pairdrop"
	Penpot                      CreateServiceJSONBodyType = "penpot"
	Phpmyadmin                  CreateServiceJSONBodyType = "phpmyadmin"
	Pocketbase                  CreateServiceJSONBodyType = "pocketbase"
	Posthog                     CreateServiceJSONBodyType = "posthog"
	ReactiveResume              CreateServiceJSONBodyType = "reactive-resume"
	Rocketchat                  CreateServiceJSONBodyType = "rocketchat"
	Shlink                      CreateServiceJSONBodyType = "shlink"
	Slash                       CreateServiceJSONBodyType = "slash"
	Snapdrop                    CreateServiceJSONBodyType = "snapdrop"
	Statusnook                  CreateServiceJSONBodyType = "statusnook"
	StirlingPdf                 CreateServiceJSONBodyType = "stirling-pdf"
	Supabase                    CreateServiceJSONBodyType = "supabase"
	Syncthing                   CreateServiceJSONBodyType = "syncthing"
	Tolgee                      CreateServiceJSONBodyType = "tolgee"
	Trigger                     CreateServiceJSONBodyType = "trigger"
	TriggerWithExternalDatabase CreateServiceJSONBodyType = "trigger-with-external-database"
	Twenty                      CreateServiceJSONBodyType = "twenty"
	Umami                       CreateServiceJSONBodyType = "umami"
	UnleashWithPostgresql       CreateServiceJSONBodyType = "unleash-with-postgresql"
	UnleashWithoutDatabase      CreateServiceJSONBodyType = "unleash-without-database"
	UptimeKuma                  CreateServiceJSONBodyType = "uptime-kuma"
	Vaultwarden                 CreateServiceJSONBodyType = "vaultwarden"
	Vikunja                     CreateServiceJSONBodyType = "vikunja"
	Weblate                     CreateServiceJSONBodyType = "weblate"
	Whoogle                     CreateServiceJSONBodyType = "whoogle"
	WordpressWithMariadb        CreateServiceJSONBodyType = "wordpress-with-mariadb"
	WordpressWithMysql          CreateServiceJSONBodyType = "wordpress-with-mysql"
	WordpressWithoutDatabase    CreateServiceJSONBodyType = "wordpress-without-database"
)

// Application Application model
type Application struct {
	// BaseDirectory Base directory for all commands.
	BaseDirectory *string `json:"base_directory,omitempty"`

	// BuildCommand Build command.
	BuildCommand *string `json:"build_command,omitempty"`

	// BuildPack Build pack.
	BuildPack *ApplicationBuildPack `json:"build_pack,omitempty"`

	// ComposeParsingVersion How Coolify parse the compose file.
	ComposeParsingVersion *string `json:"compose_parsing_version,omitempty"`

	// ConfigHash Configuration hash.
	ConfigHash *string `json:"config_hash,omitempty"`

	// CreatedAt The date and time when the application was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options"`

	// CustomHealthcheckFound Custom healthcheck found.
	CustomHealthcheckFound *bool `json:"custom_healthcheck_found,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels"`

	// CustomNginxConfiguration Custom Nginx configuration base64 encoded.
	CustomNginxConfiguration *string `json:"custom_nginx_configuration"`

	// DeletedAt The date and time when the application was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description The application description.
	Description *string `json:"description"`

	// DestinationId Destination identifier.
	DestinationId *int `json:"destination_id,omitempty"`

	// DestinationType Destination type.
	DestinationType *string `json:"destination_type,omitempty"`

	// DockerCompose Docker compose content. Used for docker compose build pack.
	DockerCompose *string `json:"docker_compose"`

	// DockerComposeCustomBuildCommand Docker compose custom build command.
	DockerComposeCustomBuildCommand *string `json:"docker_compose_custom_build_command"`

	// DockerComposeCustomStartCommand Docker compose custom start command.
	DockerComposeCustomStartCommand *string `json:"docker_compose_custom_start_command"`

	// DockerComposeDomains Docker compose domains.
	DockerComposeDomains *string `json:"docker_compose_domains"`

	// DockerComposeLocation Docker compose location.
	DockerComposeLocation *string `json:"docker_compose_location,omitempty"`

	// DockerComposeRaw Docker compose raw content.
	DockerComposeRaw *string `json:"docker_compose_raw"`

	// DockerRegistryImageName Docker registry image name.
	DockerRegistryImageName *string `json:"docker_registry_image_name"`

	// DockerRegistryImageTag Docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag"`

	// Dockerfile Dockerfile content. Used for dockerfile build pack.
	Dockerfile *string `json:"dockerfile"`

	// DockerfileLocation Dockerfile location.
	DockerfileLocation *string `json:"dockerfile_location,omitempty"`

	// DockerfileTargetBuild Dockerfile target build.
	DockerfileTargetBuild *string `json:"dockerfile_target_build"`

	// EnvironmentId Environment identifier.
	EnvironmentId *int `json:"environment_id,omitempty"`

	// Fqdn The application domains.
	Fqdn *string `json:"fqdn"`

	// GitBranch Git branch.
	GitBranch *string `json:"git_branch,omitempty"`

	// GitCommitSha Git commit SHA.
	GitCommitSha *string `json:"git_commit_sha,omitempty"`

	// GitFullUrl Git full URL.
	GitFullUrl *string `json:"git_full_url"`

	// GitRepository Git repository URL.
	GitRepository *string `json:"git_repository,omitempty"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// Id The application identifier in the database.
	Id *int `json:"id,omitempty"`

	// InstallCommand Install command.
	InstallCommand *string `json:"install_command,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea"`

	// ManualWebhookSecretGithub Manual webhook secret for GitHub.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github"`

	// ManualWebhookSecretGitlab Manual webhook secret for GitLab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes Ports exposes.
	PortsExposes *string `json:"ports_exposes,omitempty"`

	// PortsMappings Ports mappings.
	PortsMappings *string `json:"ports_mappings"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container"`

	// PreviewUrlTemplate Preview URL template.
	PreviewUrlTemplate *string `json:"preview_url_template,omitempty"`

	// PrivateKeyId Private key identifier.
	PrivateKeyId *int `json:"private_key_id"`

	// PublishDirectory Publish directory.
	PublishDirectory *string `json:"publish_directory,omitempty"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *ApplicationRedirect `json:"redirect"`

	// RepositoryProjectId The repository project identifier.
	RepositoryProjectId *int `json:"repository_project_id"`

	// SourceId Source identifier.
	SourceId *int `json:"source_id"`

	// StartCommand Start command.
	StartCommand *string `json:"start_command,omitempty"`

	// StaticImage Static image used when static site is deployed.
	StaticImage *string `json:"static_image,omitempty"`

	// Status Application status.
	Status *string `json:"status,omitempty"`

	// SwarmPlacementConstraints Swarm placement constraints. Only used for swarm deployments.
	SwarmPlacementConstraints *string `json:"swarm_placement_constraints"`

	// SwarmReplicas Swarm replicas. Only used for swarm deployments.
	SwarmReplicas *int `json:"swarm_replicas"`

	// UpdatedAt The date and time when the application was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Uuid The application UUID.
	Uuid *string `json:"uuid,omitempty"`

	// WatchPaths Watch paths.
	WatchPaths *string `json:"watch_paths"`
}

// ApplicationBuildPack Build pack.
type ApplicationBuildPack string

// ApplicationRedirect How to set redirect with Traefik / Caddy. www<->non-www.
type ApplicationRedirect string

// ApplicationDeploymentQueue Project model
type ApplicationDeploymentQueue struct {
	ApplicationId    *string `json:"application_id,omitempty"`
	ApplicationName  *string `json:"application_name,omitempty"`
	Commit           *string `json:"commit,omitempty"`
	CommitMessage    *string `json:"commit_message,omitempty"`
	CreatedAt        *string `json:"created_at,omitempty"`
	CurrentProcessId *string `json:"current_process_id,omitempty"`
	DeploymentUrl    *string `json:"deployment_url,omitempty"`
	DeploymentUuid   *string `json:"deployment_uuid,omitempty"`
	DestinationId    *string `json:"destination_id,omitempty"`
	ForceRebuild     *bool   `json:"force_rebuild,omitempty"`
	GitType          *string `json:"git_type,omitempty"`
	Id               *int    `json:"id,omitempty"`
	IsApi            *bool   `json:"is_api,omitempty"`
	IsWebhook        *bool   `json:"is_webhook,omitempty"`
	Logs             *string `json:"logs,omitempty"`
	OnlyThisServer   *bool   `json:"only_this_server,omitempty"`
	PullRequestId    *int    `json:"pull_request_id,omitempty"`
	RestartOnly      *bool   `json:"restart_only,omitempty"`
	Rollback         *bool   `json:"rollback,omitempty"`
	ServerId         *int    `json:"server_id,omitempty"`
	ServerName       *string `json:"server_name,omitempty"`
	Status           *string `json:"status,omitempty"`
	UpdatedAt        *string `json:"updated_at,omitempty"`
}

// Database defines model for Database.
type Database struct {
	union json.RawMessage
}

// DatabaseCommon defines model for DatabaseCommon.
type DatabaseCommon struct {
	CreatedAt               *time.Time `json:"created_at,omitempty"`
	DatabaseType            string     `json:"database_type"`
	DeletedAt               *time.Time `json:"deleted_at,omitempty"`
	Description             *string    `json:"description,omitempty"`
	Image                   *string    `json:"image,omitempty"`
	InternalDbUrl           *string    `json:"internal_db_url,omitempty"`
	IsPublic                *bool      `json:"is_public,omitempty"`
	LimitsCpuShares         *int       `json:"limits_cpu_shares,omitempty"`
	LimitsCpus              *string    `json:"limits_cpus,omitempty"`
	LimitsCpuset            *string    `json:"limits_cpuset"`
	LimitsMemory            *string    `json:"limits_memory,omitempty"`
	LimitsMemoryReservation *string    `json:"limits_memory_reservation,omitempty"`
	LimitsMemorySwap        *string    `json:"limits_memory_swap,omitempty"`
	LimitsMemorySwappiness  *int       `json:"limits_memory_swappiness,omitempty"`
	Name                    *string    `json:"name,omitempty"`
	PublicPort              *int       `json:"public_port"`
	UpdatedAt               *time.Time `json:"updated_at,omitempty"`
	Uuid                    string     `json:"uuid"`
}

// Environment Environment model
type Environment struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	ProjectId   *int    `json:"project_id,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

// EnvironmentVariable Environment Variable model
type EnvironmentVariable struct {
	CreatedAt        *string `json:"created_at,omitempty"`
	Id               *int    `json:"id,omitempty"`
	IsBuildTime      *bool   `json:"is_build_time,omitempty"`
	IsLiteral        *bool   `json:"is_literal,omitempty"`
	IsMultiline      *bool   `json:"is_multiline,omitempty"`
	IsPreview        *bool   `json:"is_preview,omitempty"`
	IsShared         *bool   `json:"is_shared,omitempty"`
	IsShownOnce      *bool   `json:"is_shown_once,omitempty"`
	Key              *string `json:"key,omitempty"`
	RealValue        *string `json:"real_value,omitempty"`
	ResourceableId   *int    `json:"resourceable_id,omitempty"`
	ResourceableType *string `json:"resourceable_type,omitempty"`
	UpdatedAt        *string `json:"updated_at,omitempty"`
	Uuid             *string `json:"uuid,omitempty"`
	Value            *string `json:"value,omitempty"`
	Version          *string `json:"version,omitempty"`
}

// MysqlDatabase defines model for MysqlDatabase.
type MysqlDatabase struct {
	CreatedAt               *time.Time `json:"created_at,omitempty"`
	DatabaseType            string     `json:"database_type"`
	DeletedAt               *time.Time `json:"deleted_at,omitempty"`
	Description             *string    `json:"description,omitempty"`
	Image                   *string    `json:"image,omitempty"`
	InternalDbUrl           *string    `json:"internal_db_url,omitempty"`
	IsPublic                *bool      `json:"is_public,omitempty"`
	LimitsCpuShares         *int       `json:"limits_cpu_shares,omitempty"`
	LimitsCpus              *string    `json:"limits_cpus,omitempty"`
	LimitsCpuset            *string    `json:"limits_cpuset"`
	LimitsMemory            *string    `json:"limits_memory,omitempty"`
	LimitsMemoryReservation *string    `json:"limits_memory_reservation,omitempty"`
	LimitsMemorySwap        *string    `json:"limits_memory_swap,omitempty"`
	LimitsMemorySwappiness  *int       `json:"limits_memory_swappiness,omitempty"`
	MysqlConf               *string    `json:"mysql_conf"`
	MysqlDatabase           *string    `json:"mysql_database,omitempty"`
	MysqlPassword           *string    `json:"mysql_password,omitempty"`
	MysqlRootPassword       *string    `json:"mysql_root_password,omitempty"`
	MysqlUser               *string    `json:"mysql_user,omitempty"`
	Name                    *string    `json:"name,omitempty"`
	PublicPort              *int       `json:"public_port"`
	UpdatedAt               *time.Time `json:"updated_at,omitempty"`
	Uuid                    string     `json:"uuid"`
}

// PostgresqlDatabase defines model for PostgresqlDatabase.
type PostgresqlDatabase struct {
	CreatedAt               *time.Time `json:"created_at,omitempty"`
	DatabaseType            string     `json:"database_type"`
	DeletedAt               *time.Time `json:"deleted_at,omitempty"`
	Description             *string    `json:"description,omitempty"`
	Image                   *string    `json:"image,omitempty"`
	InternalDbUrl           *string    `json:"internal_db_url,omitempty"`
	IsPublic                *bool      `json:"is_public,omitempty"`
	LimitsCpuShares         *int       `json:"limits_cpu_shares,omitempty"`
	LimitsCpus              *string    `json:"limits_cpus,omitempty"`
	LimitsCpuset            *string    `json:"limits_cpuset"`
	LimitsMemory            *string    `json:"limits_memory,omitempty"`
	LimitsMemoryReservation *string    `json:"limits_memory_reservation,omitempty"`
	LimitsMemorySwap        *string    `json:"limits_memory_swap,omitempty"`
	LimitsMemorySwappiness  *int       `json:"limits_memory_swappiness,omitempty"`
	Name                    *string    `json:"name,omitempty"`
	PostgresConf            *string    `json:"postgres_conf"`
	PostgresDb              *string    `json:"postgres_db,omitempty"`
	PostgresHostAuthMethod  *string    `json:"postgres_host_auth_method,omitempty"`
	PostgresInitdbArgs      *string    `json:"postgres_initdb_args,omitempty"`
	PostgresPassword        *string    `json:"postgres_password,omitempty"`
	PostgresUser            *string    `json:"postgres_user,omitempty"`
	PublicPort              *int       `json:"public_port"`
	UpdatedAt               *time.Time `json:"updated_at,omitempty"`
	Uuid                    string     `json:"uuid"`
}

// PrivateKey Private Key model
type PrivateKey struct {
	CreatedAt    *string `json:"created_at,omitempty"`
	Description  *string `json:"description,omitempty"`
	Fingerprint  *string `json:"fingerprint,omitempty"`
	Id           *int    `json:"id,omitempty"`
	IsGitRelated *bool   `json:"is_git_related,omitempty"`
	Name         *string `json:"name,omitempty"`
	PrivateKey   *string `json:"private_key,omitempty"`
	TeamId       *int    `json:"team_id,omitempty"`
	UpdatedAt    *string `json:"updated_at,omitempty"`
	Uuid         *string `json:"uuid,omitempty"`
}

// Project Project model
type Project struct {
	Description *string `json:"description,omitempty"`

	// Environments The environments of the project.
	Environments *[]Environment `json:"environments,omitempty"`
	Id           *int           `json:"id,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Uuid         *string        `json:"uuid,omitempty"`
}

// Server Server model
type Server struct {
	// Description The server description.
	Description *string `json:"description,omitempty"`

	// HighDiskUsageNotificationSent The flag to indicate if the high disk usage notification has been sent.
	HighDiskUsageNotificationSent *bool `json:"high_disk_usage_notification_sent,omitempty"`

	// Id The server ID.
	Id *int `json:"id,omitempty"`

	// Ip The IP address.
	Ip *string `json:"ip,omitempty"`

	// LogDrainNotificationSent The flag to indicate if the log drain notification has been sent.
	LogDrainNotificationSent *bool `json:"log_drain_notification_sent,omitempty"`

	// Name The server name.
	Name *string `json:"name,omitempty"`

	// Port The port number.
	Port *int `json:"port,omitempty"`

	// ProxyType The proxy type.
	ProxyType *ServerProxyType `json:"proxy_type,omitempty"`

	// Settings Server Settings model
	Settings *ServerSetting `json:"settings,omitempty"`

	// SwarmCluster The swarm cluster configuration.
	SwarmCluster *string `json:"swarm_cluster,omitempty"`

	// UnreachableCount The unreachable count for your server.
	UnreachableCount *int `json:"unreachable_count,omitempty"`

	// UnreachableNotificationSent The flag to indicate if the unreachable notification has been sent.
	UnreachableNotificationSent *bool `json:"unreachable_notification_sent,omitempty"`

	// User The user.
	User *string `json:"user,omitempty"`

	// Uuid The server UUID.
	Uuid *string `json:"uuid,omitempty"`

	// ValidationLogs The validation logs.
	ValidationLogs *string `json:"validation_logs,omitempty"`
}

// ServerProxyType The proxy type.
type ServerProxyType string

// ServerSetting Server Settings model
type ServerSetting struct {
	ConcurrentBuilds *int    `json:"concurrent_builds,omitempty"`
	CreatedAt        *string `json:"created_at,omitempty"`

	// DeleteUnusedNetworks The flag to indicate if the unused networks should be deleted.
	DeleteUnusedNetworks *bool `json:"delete_unused_networks,omitempty"`

	// DeleteUnusedVolumes The flag to indicate if the unused volumes should be deleted.
	DeleteUnusedVolumes               *bool   `json:"delete_unused_volumes,omitempty"`
	DockerCleanupFrequency            *string `json:"docker_cleanup_frequency,omitempty"`
	DockerCleanupThreshold            *int    `json:"docker_cleanup_threshold,omitempty"`
	DynamicTimeout                    *int    `json:"dynamic_timeout,omitempty"`
	ForceDisabled                     *bool   `json:"force_disabled,omitempty"`
	ForceServerCleanup                *bool   `json:"force_server_cleanup,omitempty"`
	Id                                *int    `json:"id,omitempty"`
	IsBuildServer                     *bool   `json:"is_build_server,omitempty"`
	IsCloudflareTunnel                *bool   `json:"is_cloudflare_tunnel,omitempty"`
	IsJumpServer                      *bool   `json:"is_jump_server,omitempty"`
	IsLogdrainAxiomEnabled            *bool   `json:"is_logdrain_axiom_enabled,omitempty"`
	IsLogdrainCustomEnabled           *bool   `json:"is_logdrain_custom_enabled,omitempty"`
	IsLogdrainHighlightEnabled        *bool   `json:"is_logdrain_highlight_enabled,omitempty"`
	IsLogdrainNewrelicEnabled         *bool   `json:"is_logdrain_newrelic_enabled,omitempty"`
	IsMetricsEnabled                  *bool   `json:"is_metrics_enabled,omitempty"`
	IsReachable                       *bool   `json:"is_reachable,omitempty"`
	IsSentinelEnabled                 *bool   `json:"is_sentinel_enabled,omitempty"`
	IsSwarmManager                    *bool   `json:"is_swarm_manager,omitempty"`
	IsSwarmWorker                     *bool   `json:"is_swarm_worker,omitempty"`
	IsUsable                          *bool   `json:"is_usable,omitempty"`
	LogdrainAxiomApiKey               *string `json:"logdrain_axiom_api_key,omitempty"`
	LogdrainAxiomDatasetName          *string `json:"logdrain_axiom_dataset_name,omitempty"`
	LogdrainCustomConfig              *string `json:"logdrain_custom_config,omitempty"`
	LogdrainCustomConfigParser        *string `json:"logdrain_custom_config_parser,omitempty"`
	LogdrainHighlightProjectId        *string `json:"logdrain_highlight_project_id,omitempty"`
	LogdrainNewrelicBaseUri           *string `json:"logdrain_newrelic_base_uri,omitempty"`
	LogdrainNewrelicLicenseKey        *string `json:"logdrain_newrelic_license_key,omitempty"`
	SentinelMetricsHistoryDays        *int    `json:"sentinel_metrics_history_days,omitempty"`
	SentinelMetricsRefreshRateSeconds *int    `json:"sentinel_metrics_refresh_rate_seconds,omitempty"`
	SentinelToken                     *string `json:"sentinel_token,omitempty"`
	ServerId                          *int    `json:"server_id,omitempty"`
	UpdatedAt                         *string `json:"updated_at,omitempty"`
	WildcardDomain                    *string `json:"wildcard_domain,omitempty"`
}

// Service Service model
type Service struct {
	// ConfigHash The hash of the service configuration.
	ConfigHash *string `json:"config_hash,omitempty"`

	// ConnectToDockerNetwork The flag to connect the service to the predefined Docker network.
	ConnectToDockerNetwork *bool `json:"connect_to_docker_network,omitempty"`

	// CreatedAt The date and time when the service was created.
	CreatedAt *string `json:"created_at,omitempty"`

	// DeletedAt The date and time when the service was deleted.
	DeletedAt *string `json:"deleted_at,omitempty"`

	// Description The description of the service.
	Description *string `json:"description,omitempty"`

	// DestinationId The unique identifier of the destination where the service is running.
	DestinationId *int `json:"destination_id,omitempty"`

	// DestinationType Destination type.
	DestinationType *string `json:"destination_type,omitempty"`

	// DockerCompose The docker-compose.yml file that is parsed and modified by Coolify.
	DockerCompose *string `json:"docker_compose,omitempty"`

	// DockerComposeRaw The raw docker-compose.yml file of the service.
	DockerComposeRaw *string `json:"docker_compose_raw,omitempty"`

	// EnvironmentId The unique identifier of the environment where the service is attached to.
	EnvironmentId *int `json:"environment_id,omitempty"`

	// Id The unique identifier of the service. Only used for database identification.
	Id *int `json:"id,omitempty"`

	// IsContainerLabelEscapeEnabled The flag to enable the container label escape.
	IsContainerLabelEscapeEnabled *bool `json:"is_container_label_escape_enabled,omitempty"`

	// IsContainerLabelReadonlyEnabled The flag to enable the container label readonly.
	IsContainerLabelReadonlyEnabled *bool `json:"is_container_label_readonly_enabled,omitempty"`

	// Name The name of the service.
	Name *string `json:"name,omitempty"`

	// ServerId The unique identifier of the server where the service is running.
	ServerId *int `json:"server_id,omitempty"`

	// ServiceType The type of the service.
	ServiceType *string `json:"service_type,omitempty"`

	// UpdatedAt The date and time when the service was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Uuid The unique identifier of the service.
	Uuid *string `json:"uuid,omitempty"`
}

// Team Team model
type Team struct {
	// CreatedAt The date and time the team was created.
	CreatedAt *string `json:"created_at,omitempty"`

	// CustomServerLimit The custom server limit.
	CustomServerLimit *string `json:"custom_server_limit,omitempty"`

	// Description The description of the team.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the team.
	Id *int `json:"id,omitempty"`

	// Members The members of the team.
	Members *[]User `json:"members,omitempty"`

	// Name The name of the team.
	Name *string `json:"name,omitempty"`

	// PersonalTeam Whether the team is personal or not.
	PersonalTeam *bool `json:"personal_team,omitempty"`

	// ShowBoarding Whether to show the boarding screen or not.
	ShowBoarding *bool `json:"show_boarding,omitempty"`

	// UpdatedAt The date and time the team was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// User User model
type User struct {
	// CreatedAt The date when the user was created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Email The user email.
	Email *string `json:"email,omitempty"`

	// EmailVerifiedAt The date when the user email was verified.
	EmailVerifiedAt *string `json:"email_verified_at,omitempty"`

	// ForcePasswordReset The flag to force the user to reset the password.
	ForcePasswordReset *bool `json:"force_password_reset,omitempty"`

	// Id The user identifier in the database.
	Id *int `json:"id,omitempty"`

	// MarketingEmails The flag to receive marketing emails.
	MarketingEmails *bool `json:"marketing_emails,omitempty"`

	// Name The user name.
	Name *string `json:"name,omitempty"`

	// TwoFactorConfirmedAt The date when the user two factor was confirmed.
	TwoFactorConfirmedAt *string `json:"two_factor_confirmed_at,omitempty"`

	// UpdatedAt The date when the user was updated.
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// N400 defines model for 400.
type N400 struct {
	Message *string `json:"message,omitempty"`
}

// N401 defines model for 401.
type N401 struct {
	Message *string `json:"message,omitempty"`
}

// N404 defines model for 404.
type N404 struct {
	Message *string `json:"message,omitempty"`
}

// CreateDockercomposeApplicationJSONBody defines parameters for CreateDockercomposeApplication.
type CreateDockercomposeApplicationJSONBody struct {
	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID if the server has more than one destinations.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerComposeRaw The Docker Compose raw content.
	DockerComposeRaw string `json:"docker_compose_raw"`

	// EnvironmentName The environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid The environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// ProjectUuid The project UUID.
	ProjectUuid string `json:"project_uuid"`

	// ServerUuid The server UUID.
	ServerUuid string `json:"server_uuid"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server,omitempty"`
}

// CreateDockerfileApplicationJSONBody defines parameters for CreateDockerfileApplication.
type CreateDockerfileApplicationJSONBody struct {
	// BaseDirectory The base directory for all commands.
	BaseDirectory *string `json:"base_directory,omitempty"`

	// BuildPack The build pack type.
	BuildPack *CreateDockerfileApplicationJSONBodyBuildPack `json:"build_pack,omitempty"`

	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels,omitempty"`

	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerRegistryImageName The docker registry image name.
	DockerRegistryImageName *string `json:"docker_registry_image_name,omitempty"`

	// DockerRegistryImageTag The docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag,omitempty"`

	// Dockerfile The Dockerfile content.
	Dockerfile string `json:"dockerfile"`

	// Domains The application domains.
	Domains *string `json:"domains,omitempty"`

	// EnvironmentName The environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid The environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket,omitempty"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea,omitempty"`

	// ManualWebhookSecretGithub Manual webhook secret for Github.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github,omitempty"`

	// ManualWebhookSecretGitlab Manual webhook secret for Gitlab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes The ports to expose.
	PortsExposes *string `json:"ports_exposes,omitempty"`

	// PortsMappings The ports mappings.
	PortsMappings *string `json:"ports_mappings,omitempty"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command,omitempty"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container,omitempty"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command,omitempty"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container,omitempty"`

	// ProjectUuid The project UUID.
	ProjectUuid string `json:"project_uuid"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *CreateDockerfileApplicationJSONBodyRedirect `json:"redirect"`

	// ServerUuid The server UUID.
	ServerUuid string `json:"server_uuid"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server"`
}

// CreateDockerfileApplicationJSONBodyBuildPack defines parameters for CreateDockerfileApplication.
type CreateDockerfileApplicationJSONBodyBuildPack string

// CreateDockerfileApplicationJSONBodyRedirect defines parameters for CreateDockerfileApplication.
type CreateDockerfileApplicationJSONBodyRedirect string

// CreateDockerimageApplicationJSONBody defines parameters for CreateDockerimageApplication.
type CreateDockerimageApplicationJSONBody struct {
	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels,omitempty"`

	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerRegistryImageName The docker registry image name.
	DockerRegistryImageName string `json:"docker_registry_image_name"`

	// DockerRegistryImageTag The docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag,omitempty"`

	// Domains The application domains.
	Domains *string `json:"domains,omitempty"`

	// EnvironmentName The environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid The environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket,omitempty"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea,omitempty"`

	// ManualWebhookSecretGithub Manual webhook secret for Github.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github,omitempty"`

	// ManualWebhookSecretGitlab Manual webhook secret for Gitlab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes The ports to expose.
	PortsExposes string `json:"ports_exposes"`

	// PortsMappings The ports mappings.
	PortsMappings *string `json:"ports_mappings,omitempty"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command,omitempty"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container,omitempty"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command,omitempty"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container,omitempty"`

	// ProjectUuid The project UUID.
	ProjectUuid string `json:"project_uuid"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *CreateDockerimageApplicationJSONBodyRedirect `json:"redirect"`

	// ServerUuid The server UUID.
	ServerUuid string `json:"server_uuid"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server"`
}

// CreateDockerimageApplicationJSONBodyRedirect defines parameters for CreateDockerimageApplication.
type CreateDockerimageApplicationJSONBodyRedirect string

// CreatePrivateDeployKeyApplicationJSONBody defines parameters for CreatePrivateDeployKeyApplication.
type CreatePrivateDeployKeyApplicationJSONBody struct {
	// BaseDirectory The base directory for all commands.
	BaseDirectory *string `json:"base_directory,omitempty"`

	// BuildCommand The build command.
	BuildCommand *string `json:"build_command,omitempty"`

	// BuildPack The build pack type.
	BuildPack CreatePrivateDeployKeyApplicationJSONBodyBuildPack `json:"build_pack"`

	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels,omitempty"`

	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerComposeCustomBuildCommand The Docker Compose custom build command.
	DockerComposeCustomBuildCommand *string `json:"docker_compose_custom_build_command,omitempty"`

	// DockerComposeCustomStartCommand The Docker Compose custom start command.
	DockerComposeCustomStartCommand *string `json:"docker_compose_custom_start_command,omitempty"`

	// DockerComposeDomains The Docker Compose domains.
	DockerComposeDomains *[]interface{} `json:"docker_compose_domains,omitempty"`

	// DockerComposeLocation The Docker Compose location.
	DockerComposeLocation *string `json:"docker_compose_location,omitempty"`

	// DockerComposeRaw The Docker Compose raw content.
	DockerComposeRaw *string `json:"docker_compose_raw,omitempty"`

	// DockerRegistryImageName The docker registry image name.
	DockerRegistryImageName *string `json:"docker_registry_image_name,omitempty"`

	// DockerRegistryImageTag The docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag,omitempty"`

	// Dockerfile The Dockerfile content.
	Dockerfile *string `json:"dockerfile,omitempty"`

	// Domains The application domains.
	Domains *string `json:"domains,omitempty"`

	// EnvironmentName The environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid The environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// GitBranch The git branch.
	GitBranch string `json:"git_branch"`

	// GitCommitSha The git commit SHA.
	GitCommitSha *string `json:"git_commit_sha,omitempty"`

	// GitRepository The git repository URL.
	GitRepository string `json:"git_repository"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// InstallCommand The install command.
	InstallCommand *string `json:"install_command,omitempty"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsStatic The flag to indicate if the application is static.
	IsStatic *bool `json:"is_static,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket,omitempty"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea,omitempty"`

	// ManualWebhookSecretGithub Manual webhook secret for Github.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github,omitempty"`

	// ManualWebhookSecretGitlab Manual webhook secret for Gitlab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes The ports to expose.
	PortsExposes string `json:"ports_exposes"`

	// PortsMappings The ports mappings.
	PortsMappings *string `json:"ports_mappings,omitempty"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command,omitempty"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container,omitempty"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command,omitempty"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container,omitempty"`

	// PrivateKeyUuid The private key UUID.
	PrivateKeyUuid string `json:"private_key_uuid"`

	// ProjectUuid The project UUID.
	ProjectUuid string `json:"project_uuid"`

	// PublishDirectory The publish directory.
	PublishDirectory *string `json:"publish_directory,omitempty"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *CreatePrivateDeployKeyApplicationJSONBodyRedirect `json:"redirect"`

	// ServerUuid The server UUID.
	ServerUuid string `json:"server_uuid"`

	// StartCommand The start command.
	StartCommand *string `json:"start_command,omitempty"`

	// StaticImage The static image.
	StaticImage *CreatePrivateDeployKeyApplicationJSONBodyStaticImage `json:"static_image,omitempty"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server"`

	// WatchPaths The watch paths.
	WatchPaths *string `json:"watch_paths,omitempty"`
}

// CreatePrivateDeployKeyApplicationJSONBodyBuildPack defines parameters for CreatePrivateDeployKeyApplication.
type CreatePrivateDeployKeyApplicationJSONBodyBuildPack string

// CreatePrivateDeployKeyApplicationJSONBodyRedirect defines parameters for CreatePrivateDeployKeyApplication.
type CreatePrivateDeployKeyApplicationJSONBodyRedirect string

// CreatePrivateDeployKeyApplicationJSONBodyStaticImage defines parameters for CreatePrivateDeployKeyApplication.
type CreatePrivateDeployKeyApplicationJSONBodyStaticImage string

// CreatePrivateGithubAppApplicationJSONBody defines parameters for CreatePrivateGithubAppApplication.
type CreatePrivateGithubAppApplicationJSONBody struct {
	// BaseDirectory The base directory for all commands.
	BaseDirectory *string `json:"base_directory,omitempty"`

	// BuildCommand The build command.
	BuildCommand *string `json:"build_command,omitempty"`

	// BuildPack The build pack type.
	BuildPack CreatePrivateGithubAppApplicationJSONBodyBuildPack `json:"build_pack"`

	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels,omitempty"`

	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerComposeCustomBuildCommand The Docker Compose custom build command.
	DockerComposeCustomBuildCommand *string `json:"docker_compose_custom_build_command,omitempty"`

	// DockerComposeCustomStartCommand The Docker Compose custom start command.
	DockerComposeCustomStartCommand *string `json:"docker_compose_custom_start_command,omitempty"`

	// DockerComposeDomains The Docker Compose domains.
	DockerComposeDomains *[]interface{} `json:"docker_compose_domains,omitempty"`

	// DockerComposeLocation The Docker Compose location.
	DockerComposeLocation *string `json:"docker_compose_location,omitempty"`

	// DockerComposeRaw The Docker Compose raw content.
	DockerComposeRaw *string `json:"docker_compose_raw,omitempty"`

	// DockerRegistryImageName The docker registry image name.
	DockerRegistryImageName *string `json:"docker_registry_image_name,omitempty"`

	// DockerRegistryImageTag The docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag,omitempty"`

	// Dockerfile The Dockerfile content.
	Dockerfile *string `json:"dockerfile,omitempty"`

	// Domains The application domains.
	Domains *string `json:"domains,omitempty"`

	// EnvironmentName The environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid The environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// GitBranch The git branch.
	GitBranch string `json:"git_branch"`

	// GitCommitSha The git commit SHA.
	GitCommitSha *string `json:"git_commit_sha,omitempty"`

	// GitRepository The git repository URL.
	GitRepository string `json:"git_repository"`

	// GithubAppUuid The Github App UUID.
	GithubAppUuid string `json:"github_app_uuid"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// InstallCommand The install command.
	InstallCommand *string `json:"install_command,omitempty"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsStatic The flag to indicate if the application is static.
	IsStatic *bool `json:"is_static,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket,omitempty"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea,omitempty"`

	// ManualWebhookSecretGithub Manual webhook secret for Github.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github,omitempty"`

	// ManualWebhookSecretGitlab Manual webhook secret for Gitlab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes The ports to expose.
	PortsExposes string `json:"ports_exposes"`

	// PortsMappings The ports mappings.
	PortsMappings *string `json:"ports_mappings,omitempty"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command,omitempty"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container,omitempty"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command,omitempty"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container,omitempty"`

	// ProjectUuid The project UUID.
	ProjectUuid string `json:"project_uuid"`

	// PublishDirectory The publish directory.
	PublishDirectory *string `json:"publish_directory,omitempty"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *CreatePrivateGithubAppApplicationJSONBodyRedirect `json:"redirect"`

	// ServerUuid The server UUID.
	ServerUuid string `json:"server_uuid"`

	// StartCommand The start command.
	StartCommand *string `json:"start_command,omitempty"`

	// StaticImage The static image.
	StaticImage *CreatePrivateGithubAppApplicationJSONBodyStaticImage `json:"static_image,omitempty"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server"`

	// WatchPaths The watch paths.
	WatchPaths *string `json:"watch_paths,omitempty"`
}

// CreatePrivateGithubAppApplicationJSONBodyBuildPack defines parameters for CreatePrivateGithubAppApplication.
type CreatePrivateGithubAppApplicationJSONBodyBuildPack string

// CreatePrivateGithubAppApplicationJSONBodyRedirect defines parameters for CreatePrivateGithubAppApplication.
type CreatePrivateGithubAppApplicationJSONBodyRedirect string

// CreatePrivateGithubAppApplicationJSONBodyStaticImage defines parameters for CreatePrivateGithubAppApplication.
type CreatePrivateGithubAppApplicationJSONBodyStaticImage string

// CreatePublicApplicationJSONBody defines parameters for CreatePublicApplication.
type CreatePublicApplicationJSONBody struct {
	// BaseDirectory The base directory for all commands.
	BaseDirectory *string `json:"base_directory,omitempty"`

	// BuildCommand The build command.
	BuildCommand *string `json:"build_command,omitempty"`

	// BuildPack The build pack type.
	BuildPack CreatePublicApplicationJSONBodyBuildPack `json:"build_pack"`

	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels,omitempty"`

	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerComposeCustomBuildCommand The Docker Compose custom build command.
	DockerComposeCustomBuildCommand *string `json:"docker_compose_custom_build_command,omitempty"`

	// DockerComposeCustomStartCommand The Docker Compose custom start command.
	DockerComposeCustomStartCommand *string `json:"docker_compose_custom_start_command,omitempty"`

	// DockerComposeDomains The Docker Compose domains.
	DockerComposeDomains *[]interface{} `json:"docker_compose_domains,omitempty"`

	// DockerComposeLocation The Docker Compose location.
	DockerComposeLocation *string `json:"docker_compose_location,omitempty"`

	// DockerComposeRaw The Docker Compose raw content.
	DockerComposeRaw *string `json:"docker_compose_raw,omitempty"`

	// DockerRegistryImageName The docker registry image name.
	DockerRegistryImageName *string `json:"docker_registry_image_name,omitempty"`

	// DockerRegistryImageTag The docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag,omitempty"`

	// Dockerfile The Dockerfile content.
	Dockerfile *string `json:"dockerfile,omitempty"`

	// Domains The application domains.
	Domains *string `json:"domains,omitempty"`

	// EnvironmentName The environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid The environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// GitBranch The git branch.
	GitBranch string `json:"git_branch"`

	// GitCommitSha The git commit SHA.
	GitCommitSha *string `json:"git_commit_sha,omitempty"`

	// GitRepository The git repository URL.
	GitRepository string `json:"git_repository"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// InstallCommand The install command.
	InstallCommand *string `json:"install_command,omitempty"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsStatic The flag to indicate if the application is static.
	IsStatic *bool `json:"is_static,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket,omitempty"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea,omitempty"`

	// ManualWebhookSecretGithub Manual webhook secret for Github.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github,omitempty"`

	// ManualWebhookSecretGitlab Manual webhook secret for Gitlab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes The ports to expose.
	PortsExposes string `json:"ports_exposes"`

	// PortsMappings The ports mappings.
	PortsMappings *string `json:"ports_mappings,omitempty"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command,omitempty"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container,omitempty"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command,omitempty"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container,omitempty"`

	// ProjectUuid The project UUID.
	ProjectUuid string `json:"project_uuid"`

	// PublishDirectory The publish directory.
	PublishDirectory *string `json:"publish_directory,omitempty"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *CreatePublicApplicationJSONBodyRedirect `json:"redirect"`

	// ServerUuid The server UUID.
	ServerUuid string `json:"server_uuid"`

	// StartCommand The start command.
	StartCommand *string `json:"start_command,omitempty"`

	// StaticImage The static image.
	StaticImage *CreatePublicApplicationJSONBodyStaticImage `json:"static_image,omitempty"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server"`

	// WatchPaths The watch paths.
	WatchPaths *string `json:"watch_paths,omitempty"`
}

// CreatePublicApplicationJSONBodyBuildPack defines parameters for CreatePublicApplication.
type CreatePublicApplicationJSONBodyBuildPack string

// CreatePublicApplicationJSONBodyRedirect defines parameters for CreatePublicApplication.
type CreatePublicApplicationJSONBodyRedirect string

// CreatePublicApplicationJSONBodyStaticImage defines parameters for CreatePublicApplication.
type CreatePublicApplicationJSONBodyStaticImage string

// DeleteApplicationByUuidParams defines parameters for DeleteApplicationByUuid.
type DeleteApplicationByUuidParams struct {
	// DeleteConfigurations Delete configurations.
	DeleteConfigurations *bool `form:"delete_configurations,omitempty" json:"delete_configurations,omitempty"`

	// DeleteVolumes Delete volumes.
	DeleteVolumes *bool `form:"delete_volumes,omitempty" json:"delete_volumes,omitempty"`

	// DockerCleanup Run docker cleanup.
	DockerCleanup *bool `form:"docker_cleanup,omitempty" json:"docker_cleanup,omitempty"`

	// DeleteConnectedNetworks Delete connected networks.
	DeleteConnectedNetworks *bool `form:"delete_connected_networks,omitempty" json:"delete_connected_networks,omitempty"`
}

// UpdateApplicationByUuidJSONBody defines parameters for UpdateApplicationByUuid.
type UpdateApplicationByUuidJSONBody struct {
	// BaseDirectory The base directory for all commands.
	BaseDirectory *string `json:"base_directory,omitempty"`

	// BuildCommand The build command.
	BuildCommand *string `json:"build_command,omitempty"`

	// BuildPack The build pack type.
	BuildPack *UpdateApplicationByUuidJSONBodyBuildPack `json:"build_pack,omitempty"`

	// CustomDockerRunOptions Custom docker run options.
	CustomDockerRunOptions *string `json:"custom_docker_run_options,omitempty"`

	// CustomLabels Custom labels.
	CustomLabels *string `json:"custom_labels,omitempty"`

	// Description The application description.
	Description *string `json:"description,omitempty"`

	// DestinationUuid The destination UUID.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DockerComposeCustomBuildCommand The Docker Compose custom build command.
	DockerComposeCustomBuildCommand *string `json:"docker_compose_custom_build_command,omitempty"`

	// DockerComposeCustomStartCommand The Docker Compose custom start command.
	DockerComposeCustomStartCommand *string `json:"docker_compose_custom_start_command,omitempty"`

	// DockerComposeDomains The Docker Compose domains.
	DockerComposeDomains *[]interface{} `json:"docker_compose_domains,omitempty"`

	// DockerComposeLocation The Docker Compose location.
	DockerComposeLocation *string `json:"docker_compose_location,omitempty"`

	// DockerComposeRaw The Docker Compose raw content.
	DockerComposeRaw *string `json:"docker_compose_raw,omitempty"`

	// DockerRegistryImageName The docker registry image name.
	DockerRegistryImageName *string `json:"docker_registry_image_name,omitempty"`

	// DockerRegistryImageTag The docker registry image tag.
	DockerRegistryImageTag *string `json:"docker_registry_image_tag,omitempty"`

	// Dockerfile The Dockerfile content.
	Dockerfile *string `json:"dockerfile,omitempty"`

	// Domains The application domains.
	Domains *string `json:"domains,omitempty"`

	// EnvironmentName The environment name.
	EnvironmentName *string `json:"environment_name,omitempty"`

	// GitBranch The git branch.
	GitBranch *string `json:"git_branch,omitempty"`

	// GitCommitSha The git commit SHA.
	GitCommitSha *string `json:"git_commit_sha,omitempty"`

	// GitRepository The git repository URL.
	GitRepository *string `json:"git_repository,omitempty"`

	// GithubAppUuid The Github App UUID.
	GithubAppUuid *string `json:"github_app_uuid,omitempty"`

	// HealthCheckEnabled Health check enabled.
	HealthCheckEnabled *bool `json:"health_check_enabled,omitempty"`

	// HealthCheckHost Health check host.
	HealthCheckHost *string `json:"health_check_host"`

	// HealthCheckInterval Health check interval in seconds.
	HealthCheckInterval *int `json:"health_check_interval,omitempty"`

	// HealthCheckMethod Health check method.
	HealthCheckMethod *string `json:"health_check_method,omitempty"`

	// HealthCheckPath Health check path.
	HealthCheckPath *string `json:"health_check_path,omitempty"`

	// HealthCheckPort Health check port.
	HealthCheckPort *string `json:"health_check_port"`

	// HealthCheckResponseText Health check response text.
	HealthCheckResponseText *string `json:"health_check_response_text"`

	// HealthCheckRetries Health check retries count.
	HealthCheckRetries *int `json:"health_check_retries,omitempty"`

	// HealthCheckReturnCode Health check return code.
	HealthCheckReturnCode *int `json:"health_check_return_code,omitempty"`

	// HealthCheckScheme Health check scheme.
	HealthCheckScheme *string `json:"health_check_scheme,omitempty"`

	// HealthCheckStartPeriod Health check start period in seconds.
	HealthCheckStartPeriod *int `json:"health_check_start_period,omitempty"`

	// HealthCheckTimeout Health check timeout in seconds.
	HealthCheckTimeout *int `json:"health_check_timeout,omitempty"`

	// InstallCommand The install command.
	InstallCommand *string `json:"install_command,omitempty"`

	// InstantDeploy The flag to indicate if the application should be deployed instantly.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsStatic The flag to indicate if the application is static.
	IsStatic *bool `json:"is_static,omitempty"`

	// LimitsCpuShares CPU shares.
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit.
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set.
	LimitsCpuset *string `json:"limits_cpuset"`

	// LimitsMemory Memory limit.
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation.
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit.
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness.
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// ManualWebhookSecretBitbucket Manual webhook secret for Bitbucket.
	ManualWebhookSecretBitbucket *string `json:"manual_webhook_secret_bitbucket,omitempty"`

	// ManualWebhookSecretGitea Manual webhook secret for Gitea.
	ManualWebhookSecretGitea *string `json:"manual_webhook_secret_gitea,omitempty"`

	// ManualWebhookSecretGithub Manual webhook secret for Github.
	ManualWebhookSecretGithub *string `json:"manual_webhook_secret_github,omitempty"`

	// ManualWebhookSecretGitlab Manual webhook secret for Gitlab.
	ManualWebhookSecretGitlab *string `json:"manual_webhook_secret_gitlab,omitempty"`

	// Name The application name.
	Name *string `json:"name,omitempty"`

	// PortsExposes The ports to expose.
	PortsExposes *string `json:"ports_exposes,omitempty"`

	// PortsMappings The ports mappings.
	PortsMappings *string `json:"ports_mappings,omitempty"`

	// PostDeploymentCommand Post deployment command.
	PostDeploymentCommand *string `json:"post_deployment_command,omitempty"`

	// PostDeploymentCommandContainer Post deployment command container.
	PostDeploymentCommandContainer *string `json:"post_deployment_command_container,omitempty"`

	// PreDeploymentCommand Pre deployment command.
	PreDeploymentCommand *string `json:"pre_deployment_command,omitempty"`

	// PreDeploymentCommandContainer Pre deployment command container.
	PreDeploymentCommandContainer *string `json:"pre_deployment_command_container,omitempty"`

	// ProjectUuid The project UUID.
	ProjectUuid *string `json:"project_uuid,omitempty"`

	// PublishDirectory The publish directory.
	PublishDirectory *string `json:"publish_directory,omitempty"`

	// Redirect How to set redirect with Traefik / Caddy. www<->non-www.
	Redirect *UpdateApplicationByUuidJSONBodyRedirect `json:"redirect"`

	// ServerUuid The server UUID.
	ServerUuid *string `json:"server_uuid,omitempty"`

	// StartCommand The start command.
	StartCommand *string `json:"start_command,omitempty"`

	// UseBuildServer Use build server.
	UseBuildServer *bool `json:"use_build_server"`

	// WatchPaths The watch paths.
	WatchPaths *string `json:"watch_paths,omitempty"`
}

// UpdateApplicationByUuidJSONBodyBuildPack defines parameters for UpdateApplicationByUuid.
type UpdateApplicationByUuidJSONBodyBuildPack string

// UpdateApplicationByUuidJSONBodyRedirect defines parameters for UpdateApplicationByUuid.
type UpdateApplicationByUuidJSONBodyRedirect string

// UpdateEnvByApplicationUuidJSONBody defines parameters for UpdateEnvByApplicationUuid.
type UpdateEnvByApplicationUuidJSONBody struct {
	// IsBuildTime The flag to indicate if the environment variable is used in build time.
	IsBuildTime *bool `json:"is_build_time,omitempty"`

	// IsLiteral The flag to indicate if the environment variable is a literal, nothing espaced.
	IsLiteral *bool `json:"is_literal,omitempty"`

	// IsMultiline The flag to indicate if the environment variable is multiline.
	IsMultiline *bool `json:"is_multiline,omitempty"`

	// IsPreview The flag to indicate if the environment variable is used in preview deployments.
	IsPreview *bool `json:"is_preview,omitempty"`

	// IsShownOnce The flag to indicate if the environment variable's value is shown on the UI.
	IsShownOnce *bool `json:"is_shown_once,omitempty"`

	// Key The key of the environment variable.
	Key string `json:"key"`

	// Value The value of the environment variable.
	Value string `json:"value"`
}

// CreateEnvByApplicationUuidJSONBody defines parameters for CreateEnvByApplicationUuid.
type CreateEnvByApplicationUuidJSONBody struct {
	// IsBuildTime The flag to indicate if the environment variable is used in build time.
	IsBuildTime *bool `json:"is_build_time,omitempty"`

	// IsLiteral The flag to indicate if the environment variable is a literal, nothing espaced.
	IsLiteral *bool `json:"is_literal,omitempty"`

	// IsMultiline The flag to indicate if the environment variable is multiline.
	IsMultiline *bool `json:"is_multiline,omitempty"`

	// IsPreview The flag to indicate if the environment variable is used in preview deployments.
	IsPreview *bool `json:"is_preview,omitempty"`

	// IsShownOnce The flag to indicate if the environment variable's value is shown on the UI.
	IsShownOnce *bool `json:"is_shown_once,omitempty"`

	// Key The key of the environment variable.
	Key *string `json:"key,omitempty"`

	// Value The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

// UpdateEnvsByApplicationUuidJSONBody defines parameters for UpdateEnvsByApplicationUuid.
type UpdateEnvsByApplicationUuidJSONBody struct {
	Data []struct {
		// IsBuildTime The flag to indicate if the environment variable is used in build time.
		IsBuildTime *bool `json:"is_build_time,omitempty"`

		// IsLiteral The flag to indicate if the environment variable is a literal, nothing espaced.
		IsLiteral *bool `json:"is_literal,omitempty"`

		// IsMultiline The flag to indicate if the environment variable is multiline.
		IsMultiline *bool `json:"is_multiline,omitempty"`

		// IsPreview The flag to indicate if the environment variable is used in preview deployments.
		IsPreview *bool `json:"is_preview,omitempty"`

		// IsShownOnce The flag to indicate if the environment variable's value is shown on the UI.
		IsShownOnce *bool `json:"is_shown_once,omitempty"`

		// Key The key of the environment variable.
		Key *string `json:"key,omitempty"`

		// Value The value of the environment variable.
		Value *string `json:"value,omitempty"`
	} `json:"data"`
}

// ExecuteCommandApplicationJSONBody defines parameters for ExecuteCommandApplication.
type ExecuteCommandApplicationJSONBody struct {
	// Command Command to execute.
	Command *string `json:"command,omitempty"`
}

// StartApplicationByUuidParams defines parameters for StartApplicationByUuid.
type StartApplicationByUuidParams struct {
	// Force Force rebuild.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// InstantDeploy Instant deploy (skip queuing).
	InstantDeploy *bool `form:"instant_deploy,omitempty" json:"instant_deploy,omitempty"`
}

// CreateDatabaseClickhouseJSONBody defines parameters for CreateDatabaseClickhouse.
type CreateDatabaseClickhouseJSONBody struct {
	// ClickhouseAdminPassword Clickhouse admin password
	ClickhouseAdminPassword *string `json:"clickhouse_admin_password,omitempty"`

	// ClickhouseAdminUser Clickhouse admin user
	ClickhouseAdminUser *string `json:"clickhouse_admin_user,omitempty"`

	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabaseDragonflyJSONBody defines parameters for CreateDatabaseDragonfly.
type CreateDatabaseDragonflyJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// DragonflyPassword DragonFly password
	DragonflyPassword *string `json:"dragonfly_password,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabaseKeydbJSONBody defines parameters for CreateDatabaseKeydb.
type CreateDatabaseKeydbJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// KeydbConf KeyDB conf
	KeydbConf *string `json:"keydb_conf,omitempty"`

	// KeydbPassword KeyDB password
	KeydbPassword *string `json:"keydb_password,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabaseMariadbJSONBody defines parameters for CreateDatabaseMariadb.
type CreateDatabaseMariadbJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// MariadbConf MariaDB conf
	MariadbConf *string `json:"mariadb_conf,omitempty"`

	// MariadbDatabase MariaDB database
	MariadbDatabase *string `json:"mariadb_database,omitempty"`

	// MariadbPassword MariaDB password
	MariadbPassword *string `json:"mariadb_password,omitempty"`

	// MariadbRootPassword MariaDB root password
	MariadbRootPassword *string `json:"mariadb_root_password,omitempty"`

	// MariadbUser MariaDB user
	MariadbUser *string `json:"mariadb_user,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabaseMongodbJSONBody defines parameters for CreateDatabaseMongodb.
type CreateDatabaseMongodbJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// MongoConf MongoDB conf
	MongoConf *string `json:"mongo_conf,omitempty"`

	// MongoInitdbRootUsername MongoDB initdb root username
	MongoInitdbRootUsername *string `json:"mongo_initdb_root_username,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabaseMysqlJSONBody defines parameters for CreateDatabaseMysql.
type CreateDatabaseMysqlJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// MysqlConf MySQL conf
	MysqlConf *string `json:"mysql_conf,omitempty"`

	// MysqlDatabase MySQL database
	MysqlDatabase *string `json:"mysql_database,omitempty"`

	// MysqlPassword MySQL password
	MysqlPassword *string `json:"mysql_password,omitempty"`

	// MysqlRootPassword MySQL root password
	MysqlRootPassword *string `json:"mysql_root_password,omitempty"`

	// MysqlUser MySQL user
	MysqlUser *string `json:"mysql_user,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabasePostgresqlJSONBody defines parameters for CreateDatabasePostgresql.
type CreateDatabasePostgresqlJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// PostgresConf PostgreSQL conf
	PostgresConf *string `json:"postgres_conf,omitempty"`

	// PostgresDb PostgreSQL database
	PostgresDb *string `json:"postgres_db,omitempty"`

	// PostgresHostAuthMethod PostgreSQL host auth method
	PostgresHostAuthMethod *string `json:"postgres_host_auth_method,omitempty"`

	// PostgresInitdbArgs PostgreSQL initdb args
	PostgresInitdbArgs *string `json:"postgres_initdb_args,omitempty"`

	// PostgresPassword PostgreSQL password
	PostgresPassword *string `json:"postgres_password,omitempty"`

	// PostgresUser PostgreSQL user
	PostgresUser *string `json:"postgres_user,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// CreateDatabaseRedisJSONBody defines parameters for CreateDatabaseRedis.
type CreateDatabaseRedisJSONBody struct {
	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DestinationUuid UUID of the destination if the server has multiple destinations
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Name of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// InstantDeploy Instant deploy the database
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// ProjectUuid UUID of the project
	ProjectUuid string `json:"project_uuid"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// RedisConf Redis conf
	RedisConf *string `json:"redis_conf,omitempty"`

	// RedisPassword Redis password
	RedisPassword *string `json:"redis_password,omitempty"`

	// ServerUuid UUID of the server
	ServerUuid string `json:"server_uuid"`
}

// DeleteDatabaseByUuidParams defines parameters for DeleteDatabaseByUuid.
type DeleteDatabaseByUuidParams struct {
	// DeleteConfigurations Delete configurations.
	DeleteConfigurations *bool `form:"delete_configurations,omitempty" json:"delete_configurations,omitempty"`

	// DeleteVolumes Delete volumes.
	DeleteVolumes *bool `form:"delete_volumes,omitempty" json:"delete_volumes,omitempty"`

	// DockerCleanup Run docker cleanup.
	DockerCleanup *bool `form:"docker_cleanup,omitempty" json:"docker_cleanup,omitempty"`

	// DeleteConnectedNetworks Delete connected networks.
	DeleteConnectedNetworks *bool `form:"delete_connected_networks,omitempty" json:"delete_connected_networks,omitempty"`
}

// UpdateDatabaseByUuidJSONBody defines parameters for UpdateDatabaseByUuid.
type UpdateDatabaseByUuidJSONBody struct {
	// ClickhouseAdminPassword Clickhouse admin password
	ClickhouseAdminPassword *string `json:"clickhouse_admin_password,omitempty"`

	// ClickhouseAdminUser Clickhouse admin user
	ClickhouseAdminUser *string `json:"clickhouse_admin_user,omitempty"`

	// Description Description of the database
	Description *string `json:"description,omitempty"`

	// DragonflyPassword DragonFly password
	DragonflyPassword *string `json:"dragonfly_password,omitempty"`

	// Image Docker Image of the database
	Image *string `json:"image,omitempty"`

	// IsPublic Is the database public?
	IsPublic *bool `json:"is_public,omitempty"`

	// KeydbConf KeyDB conf
	KeydbConf *string `json:"keydb_conf,omitempty"`

	// KeydbPassword KeyDB password
	KeydbPassword *string `json:"keydb_password,omitempty"`

	// LimitsCpuShares CPU shares of the database
	LimitsCpuShares *int `json:"limits_cpu_shares,omitempty"`

	// LimitsCpus CPU limit of the database
	LimitsCpus *string `json:"limits_cpus,omitempty"`

	// LimitsCpuset CPU set of the database
	LimitsCpuset *string `json:"limits_cpuset,omitempty"`

	// LimitsMemory Memory limit of the database
	LimitsMemory *string `json:"limits_memory,omitempty"`

	// LimitsMemoryReservation Memory reservation of the database
	LimitsMemoryReservation *string `json:"limits_memory_reservation,omitempty"`

	// LimitsMemorySwap Memory swap limit of the database
	LimitsMemorySwap *string `json:"limits_memory_swap,omitempty"`

	// LimitsMemorySwappiness Memory swappiness of the database
	LimitsMemorySwappiness *int `json:"limits_memory_swappiness,omitempty"`

	// MariadbConf MariaDB conf
	MariadbConf *string `json:"mariadb_conf,omitempty"`

	// MariadbDatabase MariaDB database
	MariadbDatabase *string `json:"mariadb_database,omitempty"`

	// MariadbPassword MariaDB password
	MariadbPassword *string `json:"mariadb_password,omitempty"`

	// MariadbRootPassword MariaDB root password
	MariadbRootPassword *string `json:"mariadb_root_password,omitempty"`

	// MariadbUser MariaDB user
	MariadbUser *string `json:"mariadb_user,omitempty"`

	// MongoConf Mongo conf
	MongoConf *string `json:"mongo_conf,omitempty"`

	// MongoInitdbDatabase Mongo initdb init database
	MongoInitdbDatabase *string `json:"mongo_initdb_database,omitempty"`

	// MongoInitdbRootPassword Mongo initdb root password
	MongoInitdbRootPassword *string `json:"mongo_initdb_root_password,omitempty"`

	// MongoInitdbRootUsername Mongo initdb root username
	MongoInitdbRootUsername *string `json:"mongo_initdb_root_username,omitempty"`

	// MysqlConf MySQL conf
	MysqlConf *string `json:"mysql_conf,omitempty"`

	// MysqlDatabase MySQL database
	MysqlDatabase *string `json:"mysql_database,omitempty"`

	// MysqlPassword MySQL password
	MysqlPassword *string `json:"mysql_password,omitempty"`

	// MysqlRootPassword MySQL root password
	MysqlRootPassword *string `json:"mysql_root_password,omitempty"`

	// MysqlUser MySQL user
	MysqlUser *string `json:"mysql_user,omitempty"`

	// Name Name of the database
	Name *string `json:"name,omitempty"`

	// PostgresConf PostgreSQL conf
	PostgresConf *string `json:"postgres_conf,omitempty"`

	// PostgresDb PostgreSQL database
	PostgresDb *string `json:"postgres_db,omitempty"`

	// PostgresHostAuthMethod PostgreSQL host auth method
	PostgresHostAuthMethod *string `json:"postgres_host_auth_method,omitempty"`

	// PostgresInitdbArgs PostgreSQL initdb args
	PostgresInitdbArgs *string `json:"postgres_initdb_args,omitempty"`

	// PostgresPassword PostgreSQL password
	PostgresPassword *string `json:"postgres_password,omitempty"`

	// PostgresUser PostgreSQL user
	PostgresUser *string `json:"postgres_user,omitempty"`

	// PublicPort Public port of the database
	PublicPort *int `json:"public_port,omitempty"`

	// RedisConf Redis conf
	RedisConf *string `json:"redis_conf,omitempty"`

	// RedisPassword Redis password
	RedisPassword *string `json:"redis_password,omitempty"`
}

// DeployByTagOrUuidParams defines parameters for DeployByTagOrUuid.
type DeployByTagOrUuidParams struct {
	// Tag Tag name(s). Comma separated list is also accepted.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Uuid Resource UUID(s). Comma separated list is also accepted.
	Uuid *string `form:"uuid,omitempty" json:"uuid,omitempty"`

	// Force Force rebuild (without cache)
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// CreateProjectJSONBody defines parameters for CreateProject.
type CreateProjectJSONBody struct {
	// Description The description of the project.
	Description *string `json:"description,omitempty"`

	// Name The name of the project.
	Name *string `json:"name,omitempty"`
}

// UpdateProjectByUuidJSONBody defines parameters for UpdateProjectByUuid.
type UpdateProjectByUuidJSONBody struct {
	// Description The description of the project.
	Description *string `json:"description,omitempty"`

	// Name The name of the project.
	Name *string `json:"name,omitempty"`
}

// CreatePrivateKeyJSONBody defines parameters for CreatePrivateKey.
type CreatePrivateKeyJSONBody struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	PrivateKey  string  `json:"private_key"`
}

// UpdatePrivateKeyJSONBody defines parameters for UpdatePrivateKey.
type UpdatePrivateKeyJSONBody struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	PrivateKey  string  `json:"private_key"`
}

// CreateServerJSONBody defines parameters for CreateServer.
type CreateServerJSONBody struct {
	// Description The description of the server.
	Description *string `json:"description,omitempty"`

	// InstantValidate Instant validate.
	InstantValidate *bool `json:"instant_validate,omitempty"`

	// Ip The IP of the server.
	Ip *string `json:"ip,omitempty"`

	// IsBuildServer Is build server.
	IsBuildServer *bool `json:"is_build_server,omitempty"`

	// Name The name of the server.
	Name *string `json:"name,omitempty"`

	// Port The port of the server.
	Port *int `json:"port,omitempty"`

	// PrivateKeyUuid The UUID of the private key.
	PrivateKeyUuid *string `json:"private_key_uuid,omitempty"`

	// ProxyType The proxy type.
	ProxyType *CreateServerJSONBodyProxyType `json:"proxy_type,omitempty"`

	// User The user of the server.
	User *string `json:"user,omitempty"`
}

// CreateServerJSONBodyProxyType defines parameters for CreateServer.
type CreateServerJSONBodyProxyType string

// UpdateServerByUuidJSONBody defines parameters for UpdateServerByUuid.
type UpdateServerByUuidJSONBody struct {
	// Description The description of the server.
	Description *string `json:"description,omitempty"`

	// InstantValidate Instant validate.
	InstantValidate *bool `json:"instant_validate,omitempty"`

	// Ip The IP of the server.
	Ip *string `json:"ip,omitempty"`

	// IsBuildServer Is build server.
	IsBuildServer *bool `json:"is_build_server,omitempty"`

	// Name The name of the server.
	Name *string `json:"name,omitempty"`

	// Port The port of the server.
	Port *int `json:"port,omitempty"`

	// PrivateKeyUuid The UUID of the private key.
	PrivateKeyUuid *string `json:"private_key_uuid,omitempty"`

	// ProxyType The proxy type.
	ProxyType *UpdateServerByUuidJSONBodyProxyType `json:"proxy_type,omitempty"`

	// User The user of the server.
	User *string `json:"user,omitempty"`
}

// UpdateServerByUuidJSONBodyProxyType defines parameters for UpdateServerByUuid.
type UpdateServerByUuidJSONBodyProxyType string

// CreateServiceJSONBody defines parameters for CreateService.
type CreateServiceJSONBody struct {
	// Description Description of the service.
	Description *string `json:"description"`

	// DestinationUuid Destination UUID. Required if server has multiple destinations.
	DestinationUuid *string `json:"destination_uuid,omitempty"`

	// EnvironmentName Environment name. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentName string `json:"environment_name"`

	// EnvironmentUuid Environment UUID. You need to provide at least one of environment_name or environment_uuid.
	EnvironmentUuid string `json:"environment_uuid"`

	// InstantDeploy Start the service immediately after creation.
	InstantDeploy *bool `json:"instant_deploy,omitempty"`

	// Name Name of the service.
	Name *string `json:"name,omitempty"`

	// ProjectUuid Project UUID.
	ProjectUuid string `json:"project_uuid"`

	// ServerUuid Server UUID.
	ServerUuid string `json:"server_uuid"`

	// Type The one-click service type
	Type CreateServiceJSONBodyType `json:"type"`
}

// CreateServiceJSONBodyType defines parameters for CreateService.
type CreateServiceJSONBodyType string

// DeleteServiceByUuidParams defines parameters for DeleteServiceByUuid.
type DeleteServiceByUuidParams struct {
	// DeleteConfigurations Delete configurations.
	DeleteConfigurations *bool `form:"delete_configurations,omitempty" json:"delete_configurations,omitempty"`

	// DeleteVolumes Delete volumes.
	DeleteVolumes *bool `form:"delete_volumes,omitempty" json:"delete_volumes,omitempty"`

	// DockerCleanup Run docker cleanup.
	DockerCleanup *bool `form:"docker_cleanup,omitempty" json:"docker_cleanup,omitempty"`

	// DeleteConnectedNetworks Delete connected networks.
	DeleteConnectedNetworks *bool `form:"delete_connected_networks,omitempty" json:"delete_connected_networks,omitempty"`
}

// UpdateEnvByServiceUuidJSONBody defines parameters for UpdateEnvByServiceUuid.
type UpdateEnvByServiceUuidJSONBody struct {
	// IsBuildTime The flag to indicate if the environment variable is used in build time.
	IsBuildTime *bool `json:"is_build_time,omitempty"`

	// IsLiteral The flag to indicate if the environment variable is a literal, nothing espaced.
	IsLiteral *bool `json:"is_literal,omitempty"`

	// IsMultiline The flag to indicate if the environment variable is multiline.
	IsMultiline *bool `json:"is_multiline,omitempty"`

	// IsPreview The flag to indicate if the environment variable is used in preview deployments.
	IsPreview *bool `json:"is_preview,omitempty"`

	// IsShownOnce The flag to indicate if the environment variable's value is shown on the UI.
	IsShownOnce *bool `json:"is_shown_once,omitempty"`

	// Key The key of the environment variable.
	Key string `json:"key"`

	// Value The value of the environment variable.
	Value string `json:"value"`
}

// CreateEnvByServiceUuidJSONBody defines parameters for CreateEnvByServiceUuid.
type CreateEnvByServiceUuidJSONBody struct {
	// IsBuildTime The flag to indicate if the environment variable is used in build time.
	IsBuildTime *bool `json:"is_build_time,omitempty"`

	// IsLiteral The flag to indicate if the environment variable is a literal, nothing espaced.
	IsLiteral *bool `json:"is_literal,omitempty"`

	// IsMultiline The flag to indicate if the environment variable is multiline.
	IsMultiline *bool `json:"is_multiline,omitempty"`

	// IsPreview The flag to indicate if the environment variable is used in preview deployments.
	IsPreview *bool `json:"is_preview,omitempty"`

	// IsShownOnce The flag to indicate if the environment variable's value is shown on the UI.
	IsShownOnce *bool `json:"is_shown_once,omitempty"`

	// Key The key of the environment variable.
	Key *string `json:"key,omitempty"`

	// Value The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

// UpdateEnvsByServiceUuidJSONBody defines parameters for UpdateEnvsByServiceUuid.
type UpdateEnvsByServiceUuidJSONBody struct {
	Data []struct {
		// IsBuildTime The flag to indicate if the environment variable is used in build time.
		IsBuildTime *bool `json:"is_build_time,omitempty"`

		// IsLiteral The flag to indicate if the environment variable is a literal, nothing espaced.
		IsLiteral *bool `json:"is_literal,omitempty"`

		// IsMultiline The flag to indicate if the environment variable is multiline.
		IsMultiline *bool `json:"is_multiline,omitempty"`

		// IsPreview The flag to indicate if the environment variable is used in preview deployments.
		IsPreview *bool `json:"is_preview,omitempty"`

		// IsShownOnce The flag to indicate if the environment variable's value is shown on the UI.
		IsShownOnce *bool `json:"is_shown_once,omitempty"`

		// Key The key of the environment variable.
		Key *string `json:"key,omitempty"`

		// Value The value of the environment variable.
		Value *string `json:"value,omitempty"`
	} `json:"data"`
}

// CreateDockercomposeApplicationJSONRequestBody defines body for CreateDockercomposeApplication for application/json ContentType.
type CreateDockercomposeApplicationJSONRequestBody CreateDockercomposeApplicationJSONBody

// CreateDockerfileApplicationJSONRequestBody defines body for CreateDockerfileApplication for application/json ContentType.
type CreateDockerfileApplicationJSONRequestBody CreateDockerfileApplicationJSONBody

// CreateDockerimageApplicationJSONRequestBody defines body for CreateDockerimageApplication for application/json ContentType.
type CreateDockerimageApplicationJSONRequestBody CreateDockerimageApplicationJSONBody

// CreatePrivateDeployKeyApplicationJSONRequestBody defines body for CreatePrivateDeployKeyApplication for application/json ContentType.
type CreatePrivateDeployKeyApplicationJSONRequestBody CreatePrivateDeployKeyApplicationJSONBody

// CreatePrivateGithubAppApplicationJSONRequestBody defines body for CreatePrivateGithubAppApplication for application/json ContentType.
type CreatePrivateGithubAppApplicationJSONRequestBody CreatePrivateGithubAppApplicationJSONBody

// CreatePublicApplicationJSONRequestBody defines body for CreatePublicApplication for application/json ContentType.
type CreatePublicApplicationJSONRequestBody CreatePublicApplicationJSONBody

// UpdateApplicationByUuidJSONRequestBody defines body for UpdateApplicationByUuid for application/json ContentType.
type UpdateApplicationByUuidJSONRequestBody UpdateApplicationByUuidJSONBody

// UpdateEnvByApplicationUuidJSONRequestBody defines body for UpdateEnvByApplicationUuid for application/json ContentType.
type UpdateEnvByApplicationUuidJSONRequestBody UpdateEnvByApplicationUuidJSONBody

// CreateEnvByApplicationUuidJSONRequestBody defines body for CreateEnvByApplicationUuid for application/json ContentType.
type CreateEnvByApplicationUuidJSONRequestBody CreateEnvByApplicationUuidJSONBody

// UpdateEnvsByApplicationUuidJSONRequestBody defines body for UpdateEnvsByApplicationUuid for application/json ContentType.
type UpdateEnvsByApplicationUuidJSONRequestBody UpdateEnvsByApplicationUuidJSONBody

// ExecuteCommandApplicationJSONRequestBody defines body for ExecuteCommandApplication for application/json ContentType.
type ExecuteCommandApplicationJSONRequestBody ExecuteCommandApplicationJSONBody

// CreateDatabaseClickhouseJSONRequestBody defines body for CreateDatabaseClickhouse for application/json ContentType.
type CreateDatabaseClickhouseJSONRequestBody CreateDatabaseClickhouseJSONBody

// CreateDatabaseDragonflyJSONRequestBody defines body for CreateDatabaseDragonfly for application/json ContentType.
type CreateDatabaseDragonflyJSONRequestBody CreateDatabaseDragonflyJSONBody

// CreateDatabaseKeydbJSONRequestBody defines body for CreateDatabaseKeydb for application/json ContentType.
type CreateDatabaseKeydbJSONRequestBody CreateDatabaseKeydbJSONBody

// CreateDatabaseMariadbJSONRequestBody defines body for CreateDatabaseMariadb for application/json ContentType.
type CreateDatabaseMariadbJSONRequestBody CreateDatabaseMariadbJSONBody

// CreateDatabaseMongodbJSONRequestBody defines body for CreateDatabaseMongodb for application/json ContentType.
type CreateDatabaseMongodbJSONRequestBody CreateDatabaseMongodbJSONBody

// CreateDatabaseMysqlJSONRequestBody defines body for CreateDatabaseMysql for application/json ContentType.
type CreateDatabaseMysqlJSONRequestBody CreateDatabaseMysqlJSONBody

// CreateDatabasePostgresqlJSONRequestBody defines body for CreateDatabasePostgresql for application/json ContentType.
type CreateDatabasePostgresqlJSONRequestBody CreateDatabasePostgresqlJSONBody

// CreateDatabaseRedisJSONRequestBody defines body for CreateDatabaseRedis for application/json ContentType.
type CreateDatabaseRedisJSONRequestBody CreateDatabaseRedisJSONBody

// UpdateDatabaseByUuidJSONRequestBody defines body for UpdateDatabaseByUuid for application/json ContentType.
type UpdateDatabaseByUuidJSONRequestBody UpdateDatabaseByUuidJSONBody

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody CreateProjectJSONBody

// UpdateProjectByUuidJSONRequestBody defines body for UpdateProjectByUuid for application/json ContentType.
type UpdateProjectByUuidJSONRequestBody UpdateProjectByUuidJSONBody

// CreatePrivateKeyJSONRequestBody defines body for CreatePrivateKey for application/json ContentType.
type CreatePrivateKeyJSONRequestBody CreatePrivateKeyJSONBody

// UpdatePrivateKeyJSONRequestBody defines body for UpdatePrivateKey for application/json ContentType.
type UpdatePrivateKeyJSONRequestBody UpdatePrivateKeyJSONBody

// CreateServerJSONRequestBody defines body for CreateServer for application/json ContentType.
type CreateServerJSONRequestBody CreateServerJSONBody

// UpdateServerByUuidJSONRequestBody defines body for UpdateServerByUuid for application/json ContentType.
type UpdateServerByUuidJSONRequestBody UpdateServerByUuidJSONBody

// CreateServiceJSONRequestBody defines body for CreateService for application/json ContentType.
type CreateServiceJSONRequestBody CreateServiceJSONBody

// UpdateEnvByServiceUuidJSONRequestBody defines body for UpdateEnvByServiceUuid for application/json ContentType.
type UpdateEnvByServiceUuidJSONRequestBody UpdateEnvByServiceUuidJSONBody

// CreateEnvByServiceUuidJSONRequestBody defines body for CreateEnvByServiceUuid for application/json ContentType.
type CreateEnvByServiceUuidJSONRequestBody CreateEnvByServiceUuidJSONBody

// UpdateEnvsByServiceUuidJSONRequestBody defines body for UpdateEnvsByServiceUuid for application/json ContentType.
type UpdateEnvsByServiceUuidJSONRequestBody UpdateEnvsByServiceUuidJSONBody

// AsDatabaseCommon returns the union data inside the Database as a DatabaseCommon
func (t Database) AsDatabaseCommon() (DatabaseCommon, error) {
	var body DatabaseCommon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatabaseCommon overwrites any union data inside the Database as the provided DatabaseCommon
func (t *Database) FromDatabaseCommon(v DatabaseCommon) error {
	v.DatabaseType = "DatabaseCommon"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatabaseCommon performs a merge with any union data inside the Database, using the provided DatabaseCommon
func (t *Database) MergeDatabaseCommon(v DatabaseCommon) error {
	v.DatabaseType = "DatabaseCommon"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostgresqlDatabase returns the union data inside the Database as a PostgresqlDatabase
func (t Database) AsPostgresqlDatabase() (PostgresqlDatabase, error) {
	var body PostgresqlDatabase
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresqlDatabase overwrites any union data inside the Database as the provided PostgresqlDatabase
func (t *Database) FromPostgresqlDatabase(v PostgresqlDatabase) error {
	v.DatabaseType = "standalone-postgresql"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresqlDatabase performs a merge with any union data inside the Database, using the provided PostgresqlDatabase
func (t *Database) MergePostgresqlDatabase(v PostgresqlDatabase) error {
	v.DatabaseType = "standalone-postgresql"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMysqlDatabase returns the union data inside the Database as a MysqlDatabase
func (t Database) AsMysqlDatabase() (MysqlDatabase, error) {
	var body MysqlDatabase
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMysqlDatabase overwrites any union data inside the Database as the provided MysqlDatabase
func (t *Database) FromMysqlDatabase(v MysqlDatabase) error {
	v.DatabaseType = "standalone-mysql"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMysqlDatabase performs a merge with any union data inside the Database, using the provided MysqlDatabase
func (t *Database) MergeMysqlDatabase(v MysqlDatabase) error {
	v.DatabaseType = "standalone-mysql"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Database) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"database_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Database) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabaseCommon":
		return t.AsDatabaseCommon()
	case "standalone-mysql":
		return t.AsMysqlDatabase()
	case "standalone-postgresql":
		return t.AsPostgresqlDatabase()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Database) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Database) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApplications request
	ListApplications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDockercomposeApplicationWithBody request with any body
	CreateDockercomposeApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDockercomposeApplication(ctx context.Context, body CreateDockercomposeApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDockerfileApplicationWithBody request with any body
	CreateDockerfileApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDockerfileApplication(ctx context.Context, body CreateDockerfileApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDockerimageApplicationWithBody request with any body
	CreateDockerimageApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDockerimageApplication(ctx context.Context, body CreateDockerimageApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePrivateDeployKeyApplicationWithBody request with any body
	CreatePrivateDeployKeyApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePrivateDeployKeyApplication(ctx context.Context, body CreatePrivateDeployKeyApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePrivateGithubAppApplicationWithBody request with any body
	CreatePrivateGithubAppApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePrivateGithubAppApplication(ctx context.Context, body CreatePrivateGithubAppApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicApplicationWithBody request with any body
	CreatePublicApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePublicApplication(ctx context.Context, body CreatePublicApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApplicationByUuid request
	DeleteApplicationByUuid(ctx context.Context, uuid string, params *DeleteApplicationByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationByUuid request
	GetApplicationByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApplicationByUuidWithBody request with any body
	UpdateApplicationByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApplicationByUuid(ctx context.Context, uuid string, body UpdateApplicationByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnvsByApplicationUuid request
	ListEnvsByApplicationUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvByApplicationUuidWithBody request with any body
	UpdateEnvByApplicationUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvByApplicationUuid(ctx context.Context, uuid string, body UpdateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvByApplicationUuidWithBody request with any body
	CreateEnvByApplicationUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnvByApplicationUuid(ctx context.Context, uuid string, body CreateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvsByApplicationUuidWithBody request with any body
	UpdateEnvsByApplicationUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvsByApplicationUuid(ctx context.Context, uuid string, body UpdateEnvsByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnvByApplicationUuid request
	DeleteEnvByApplicationUuid(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteCommandApplicationWithBody request with any body
	ExecuteCommandApplicationWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteCommandApplication(ctx context.Context, uuid string, body ExecuteCommandApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartApplicationByUuid request
	RestartApplicationByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartApplicationByUuid request
	StartApplicationByUuid(ctx context.Context, uuid string, params *StartApplicationByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopApplicationByUuid request
	StopApplicationByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabases request
	ListDatabases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseClickhouseWithBody request with any body
	CreateDatabaseClickhouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseClickhouse(ctx context.Context, body CreateDatabaseClickhouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseDragonflyWithBody request with any body
	CreateDatabaseDragonflyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseDragonfly(ctx context.Context, body CreateDatabaseDragonflyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseKeydbWithBody request with any body
	CreateDatabaseKeydbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseKeydb(ctx context.Context, body CreateDatabaseKeydbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseMariadbWithBody request with any body
	CreateDatabaseMariadbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseMariadb(ctx context.Context, body CreateDatabaseMariadbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseMongodbWithBody request with any body
	CreateDatabaseMongodbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseMongodb(ctx context.Context, body CreateDatabaseMongodbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseMysqlWithBody request with any body
	CreateDatabaseMysqlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseMysql(ctx context.Context, body CreateDatabaseMysqlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabasePostgresqlWithBody request with any body
	CreateDatabasePostgresqlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabasePostgresql(ctx context.Context, body CreateDatabasePostgresqlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseRedisWithBody request with any body
	CreateDatabaseRedisWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseRedis(ctx context.Context, body CreateDatabaseRedisJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabaseByUuid request
	DeleteDatabaseByUuid(ctx context.Context, uuid string, params *DeleteDatabaseByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseByUuid request
	GetDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatabaseByUuidWithBody request with any body
	UpdateDatabaseByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatabaseByUuid(ctx context.Context, uuid string, body UpdateDatabaseByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartDatabaseByUuid request
	RestartDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartDatabaseByUuid request
	StartDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopDatabaseByUuid request
	StopDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployByTagOrUuid request
	DeployByTagOrUuid(ctx context.Context, params *DeployByTagOrUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployments request
	ListDeployments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentByUuid request
	GetDeploymentByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableApi request
	DisableApi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableApi request
	EnableApi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Healthcheck request
	Healthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectByUuid request
	DeleteProjectByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectByUuid request
	GetProjectByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectByUuidWithBody request with any body
	UpdateProjectByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectByUuid(ctx context.Context, uuid string, body UpdateProjectByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentByNameOrUuid request
	GetEnvironmentByNameOrUuid(ctx context.Context, uuid string, environmentNameOrUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResources request
	ListResources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrivateKeys request
	ListPrivateKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePrivateKeyWithBody request with any body
	CreatePrivateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePrivateKey(ctx context.Context, body CreatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePrivateKeyByUuid request
	DeletePrivateKeyByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateKeyByUuid request
	GetPrivateKeyByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePrivateKeyWithBody request with any body
	UpdatePrivateKeyWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePrivateKey(ctx context.Context, uuid string, body UpdatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServers request
	ListServers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerWithBody request with any body
	CreateServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServer(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerByUuid request
	DeleteServerByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerByUuid request
	GetServerByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServerByUuidWithBody request with any body
	UpdateServerByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServerByUuid(ctx context.Context, uuid string, body UpdateServerByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainsByServerUuid request
	GetDomainsByServerUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcesByServerUuid request
	GetResourcesByServerUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateServerByUuid request
	ValidateServerByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServices request
	ListServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceWithBody request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceByUuid request
	DeleteServiceByUuid(ctx context.Context, uuid string, params *DeleteServiceByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceByUuid request
	GetServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnvsByServiceUuid request
	ListEnvsByServiceUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvByServiceUuidWithBody request with any body
	UpdateEnvByServiceUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvByServiceUuid(ctx context.Context, uuid string, body UpdateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvByServiceUuidWithBody request with any body
	CreateEnvByServiceUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnvByServiceUuid(ctx context.Context, uuid string, body CreateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvsByServiceUuidWithBody request with any body
	UpdateEnvsByServiceUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvsByServiceUuid(ctx context.Context, uuid string, body UpdateEnvsByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnvByServiceUuid request
	DeleteEnvByServiceUuid(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartServiceByUuid request
	RestartServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartServiceByUuid request
	StartServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopServiceByUuid request
	StopServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentTeam request
	GetCurrentTeam(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentTeamMembers request
	GetCurrentTeamMembers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamById request
	GetTeamById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMembersByTeamId request
	GetMembersByTeamId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Version request
	Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApplications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDockercomposeApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDockercomposeApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDockercomposeApplication(ctx context.Context, body CreateDockercomposeApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDockercomposeApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDockerfileApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDockerfileApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDockerfileApplication(ctx context.Context, body CreateDockerfileApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDockerfileApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDockerimageApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDockerimageApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDockerimageApplication(ctx context.Context, body CreateDockerimageApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDockerimageApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateDeployKeyApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateDeployKeyApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateDeployKeyApplication(ctx context.Context, body CreatePrivateDeployKeyApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateDeployKeyApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateGithubAppApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateGithubAppApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateGithubAppApplication(ctx context.Context, body CreatePrivateGithubAppApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateGithubAppApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicApplication(ctx context.Context, body CreatePublicApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApplicationByUuid(ctx context.Context, uuid string, params *DeleteApplicationByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApplicationByUuidRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplicationByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplicationByUuid(ctx context.Context, uuid string, body UpdateApplicationByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvsByApplicationUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnvsByApplicationUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvByApplicationUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvByApplicationUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvByApplicationUuid(ctx context.Context, uuid string, body UpdateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvByApplicationUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvByApplicationUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvByApplicationUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvByApplicationUuid(ctx context.Context, uuid string, body CreateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvByApplicationUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvsByApplicationUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvsByApplicationUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvsByApplicationUuid(ctx context.Context, uuid string, body UpdateEnvsByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvsByApplicationUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvByApplicationUuid(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvByApplicationUuidRequest(c.Server, uuid, envUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteCommandApplicationWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteCommandApplicationRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteCommandApplication(ctx context.Context, uuid string, body ExecuteCommandApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteCommandApplicationRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartApplicationByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartApplicationByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplicationByUuid(ctx context.Context, uuid string, params *StartApplicationByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationByUuidRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplicationByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabasesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseClickhouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseClickhouseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseClickhouse(ctx context.Context, body CreateDatabaseClickhouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseClickhouseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseDragonflyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseDragonflyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseDragonfly(ctx context.Context, body CreateDatabaseDragonflyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseDragonflyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseKeydbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseKeydbRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseKeydb(ctx context.Context, body CreateDatabaseKeydbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseKeydbRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseMariadbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseMariadbRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseMariadb(ctx context.Context, body CreateDatabaseMariadbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseMariadbRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseMongodbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseMongodbRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseMongodb(ctx context.Context, body CreateDatabaseMongodbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseMongodbRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseMysqlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseMysqlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseMysql(ctx context.Context, body CreateDatabaseMysqlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseMysqlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabasePostgresqlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabasePostgresqlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabasePostgresql(ctx context.Context, body CreateDatabasePostgresqlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabasePostgresqlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseRedisWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRedisRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseRedis(ctx context.Context, body CreateDatabaseRedisJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRedisRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabaseByUuid(ctx context.Context, uuid string, params *DeleteDatabaseByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabaseByUuidRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseByUuid(ctx context.Context, uuid string, body UpdateDatabaseByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartDatabaseByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartDatabaseByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopDatabaseByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopDatabaseByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployByTagOrUuid(ctx context.Context, params *DeployByTagOrUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployByTagOrUuidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableApi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableApiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableApi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableApiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Healthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectByUuid(ctx context.Context, uuid string, body UpdateProjectByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentByNameOrUuid(ctx context.Context, uuid string, environmentNameOrUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentByNameOrUuidRequest(c.Server, uuid, environmentNameOrUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourcesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrivateKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrivateKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateKey(ctx context.Context, body CreatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePrivateKeyByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePrivateKeyByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateKeyByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateKeyByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrivateKeyWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePrivateKeyRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrivateKey(ctx context.Context, uuid string, body UpdatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePrivateKeyRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServer(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerByUuid(ctx context.Context, uuid string, body UpdateServerByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainsByServerUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainsByServerUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcesByServerUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesByServerUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateServerByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateServerByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceByUuid(ctx context.Context, uuid string, params *DeleteServiceByUuidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceByUuidRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvsByServiceUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnvsByServiceUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvByServiceUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvByServiceUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvByServiceUuid(ctx context.Context, uuid string, body UpdateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvByServiceUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvByServiceUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvByServiceUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvByServiceUuid(ctx context.Context, uuid string, body CreateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvByServiceUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvsByServiceUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvsByServiceUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvsByServiceUuid(ctx context.Context, uuid string, body UpdateEnvsByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvsByServiceUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvByServiceUuid(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvByServiceUuidRequest(c.Server, uuid, envUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartServiceByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartServiceByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopServiceByUuid(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopServiceByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentTeam(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentTeamRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentTeamMembers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentTeamMembersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMembersByTeamId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMembersByTeamIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListApplicationsRequest generates requests for ListApplications
func NewListApplicationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDockercomposeApplicationRequest calls the generic CreateDockercomposeApplication builder with application/json body
func NewCreateDockercomposeApplicationRequest(server string, body CreateDockercomposeApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDockercomposeApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDockercomposeApplicationRequestWithBody generates requests for CreateDockercomposeApplication with any type of body
func NewCreateDockercomposeApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/dockercompose")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDockerfileApplicationRequest calls the generic CreateDockerfileApplication builder with application/json body
func NewCreateDockerfileApplicationRequest(server string, body CreateDockerfileApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDockerfileApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDockerfileApplicationRequestWithBody generates requests for CreateDockerfileApplication with any type of body
func NewCreateDockerfileApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/dockerfile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDockerimageApplicationRequest calls the generic CreateDockerimageApplication builder with application/json body
func NewCreateDockerimageApplicationRequest(server string, body CreateDockerimageApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDockerimageApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDockerimageApplicationRequestWithBody generates requests for CreateDockerimageApplication with any type of body
func NewCreateDockerimageApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/dockerimage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePrivateDeployKeyApplicationRequest calls the generic CreatePrivateDeployKeyApplication builder with application/json body
func NewCreatePrivateDeployKeyApplicationRequest(server string, body CreatePrivateDeployKeyApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePrivateDeployKeyApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePrivateDeployKeyApplicationRequestWithBody generates requests for CreatePrivateDeployKeyApplication with any type of body
func NewCreatePrivateDeployKeyApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/private-deploy-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePrivateGithubAppApplicationRequest calls the generic CreatePrivateGithubAppApplication builder with application/json body
func NewCreatePrivateGithubAppApplicationRequest(server string, body CreatePrivateGithubAppApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePrivateGithubAppApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePrivateGithubAppApplicationRequestWithBody generates requests for CreatePrivateGithubAppApplication with any type of body
func NewCreatePrivateGithubAppApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/private-github-app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePublicApplicationRequest calls the generic CreatePublicApplication builder with application/json body
func NewCreatePublicApplicationRequest(server string, body CreatePublicApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePublicApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePublicApplicationRequestWithBody generates requests for CreatePublicApplication with any type of body
func NewCreatePublicApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApplicationByUuidRequest generates requests for DeleteApplicationByUuid
func NewDeleteApplicationByUuidRequest(server string, uuid string, params *DeleteApplicationByUuidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteConfigurations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_configurations", runtime.ParamLocationQuery, *params.DeleteConfigurations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteVolumes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_volumes", runtime.ParamLocationQuery, *params.DeleteVolumes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DockerCleanup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "docker_cleanup", runtime.ParamLocationQuery, *params.DockerCleanup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteConnectedNetworks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_connected_networks", runtime.ParamLocationQuery, *params.DeleteConnectedNetworks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationByUuidRequest generates requests for GetApplicationByUuid
func NewGetApplicationByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateApplicationByUuidRequest calls the generic UpdateApplicationByUuid builder with application/json body
func NewUpdateApplicationByUuidRequest(server string, uuid string, body UpdateApplicationByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateApplicationByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateApplicationByUuidRequestWithBody generates requests for UpdateApplicationByUuid with any type of body
func NewUpdateApplicationByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEnvsByApplicationUuidRequest generates requests for ListEnvsByApplicationUuid
func NewListEnvsByApplicationUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/envs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnvByApplicationUuidRequest calls the generic UpdateEnvByApplicationUuid builder with application/json body
func NewUpdateEnvByApplicationUuidRequest(server string, uuid string, body UpdateEnvByApplicationUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvByApplicationUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateEnvByApplicationUuidRequestWithBody generates requests for UpdateEnvByApplicationUuid with any type of body
func NewUpdateEnvByApplicationUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/envs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEnvByApplicationUuidRequest calls the generic CreateEnvByApplicationUuid builder with application/json body
func NewCreateEnvByApplicationUuidRequest(server string, uuid string, body CreateEnvByApplicationUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvByApplicationUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewCreateEnvByApplicationUuidRequestWithBody generates requests for CreateEnvByApplicationUuid with any type of body
func NewCreateEnvByApplicationUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/envs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEnvsByApplicationUuidRequest calls the generic UpdateEnvsByApplicationUuid builder with application/json body
func NewUpdateEnvsByApplicationUuidRequest(server string, uuid string, body UpdateEnvsByApplicationUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvsByApplicationUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateEnvsByApplicationUuidRequestWithBody generates requests for UpdateEnvsByApplicationUuid with any type of body
func NewUpdateEnvsByApplicationUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/envs/bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvByApplicationUuidRequest generates requests for DeleteEnvByApplicationUuid
func NewDeleteEnvByApplicationUuidRequest(server string, uuid string, envUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "env_uuid", runtime.ParamLocationPath, envUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/envs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteCommandApplicationRequest calls the generic ExecuteCommandApplication builder with application/json body
func NewExecuteCommandApplicationRequest(server string, uuid string, body ExecuteCommandApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteCommandApplicationRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewExecuteCommandApplicationRequestWithBody generates requests for ExecuteCommandApplication with any type of body
func NewExecuteCommandApplicationRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/execute", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestartApplicationByUuidRequest generates requests for RestartApplicationByUuid
func NewRestartApplicationByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartApplicationByUuidRequest generates requests for StartApplicationByUuid
func NewStartApplicationByUuidRequest(server string, uuid string, params *StartApplicationByUuidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstantDeploy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instant_deploy", runtime.ParamLocationQuery, *params.InstantDeploy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopApplicationByUuidRequest generates requests for StopApplicationByUuid
func NewStopApplicationByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabasesRequest generates requests for ListDatabases
func NewListDatabasesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseClickhouseRequest calls the generic CreateDatabaseClickhouse builder with application/json body
func NewCreateDatabaseClickhouseRequest(server string, body CreateDatabaseClickhouseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseClickhouseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseClickhouseRequestWithBody generates requests for CreateDatabaseClickhouse with any type of body
func NewCreateDatabaseClickhouseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/clickhouse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseDragonflyRequest calls the generic CreateDatabaseDragonfly builder with application/json body
func NewCreateDatabaseDragonflyRequest(server string, body CreateDatabaseDragonflyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseDragonflyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseDragonflyRequestWithBody generates requests for CreateDatabaseDragonfly with any type of body
func NewCreateDatabaseDragonflyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/dragonfly")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseKeydbRequest calls the generic CreateDatabaseKeydb builder with application/json body
func NewCreateDatabaseKeydbRequest(server string, body CreateDatabaseKeydbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseKeydbRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseKeydbRequestWithBody generates requests for CreateDatabaseKeydb with any type of body
func NewCreateDatabaseKeydbRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/keydb")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseMariadbRequest calls the generic CreateDatabaseMariadb builder with application/json body
func NewCreateDatabaseMariadbRequest(server string, body CreateDatabaseMariadbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseMariadbRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseMariadbRequestWithBody generates requests for CreateDatabaseMariadb with any type of body
func NewCreateDatabaseMariadbRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/mariadb")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseMongodbRequest calls the generic CreateDatabaseMongodb builder with application/json body
func NewCreateDatabaseMongodbRequest(server string, body CreateDatabaseMongodbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseMongodbRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseMongodbRequestWithBody generates requests for CreateDatabaseMongodb with any type of body
func NewCreateDatabaseMongodbRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/mongodb")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseMysqlRequest calls the generic CreateDatabaseMysql builder with application/json body
func NewCreateDatabaseMysqlRequest(server string, body CreateDatabaseMysqlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseMysqlRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseMysqlRequestWithBody generates requests for CreateDatabaseMysql with any type of body
func NewCreateDatabaseMysqlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/mysql")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabasePostgresqlRequest calls the generic CreateDatabasePostgresql builder with application/json body
func NewCreateDatabasePostgresqlRequest(server string, body CreateDatabasePostgresqlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabasePostgresqlRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabasePostgresqlRequestWithBody generates requests for CreateDatabasePostgresql with any type of body
func NewCreateDatabasePostgresqlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/postgresql")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseRedisRequest calls the generic CreateDatabaseRedis builder with application/json body
func NewCreateDatabaseRedisRequest(server string, body CreateDatabaseRedisJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRedisRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRedisRequestWithBody generates requests for CreateDatabaseRedis with any type of body
func NewCreateDatabaseRedisRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/redis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabaseByUuidRequest generates requests for DeleteDatabaseByUuid
func NewDeleteDatabaseByUuidRequest(server string, uuid string, params *DeleteDatabaseByUuidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteConfigurations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_configurations", runtime.ParamLocationQuery, *params.DeleteConfigurations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteVolumes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_volumes", runtime.ParamLocationQuery, *params.DeleteVolumes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DockerCleanup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "docker_cleanup", runtime.ParamLocationQuery, *params.DockerCleanup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteConnectedNetworks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_connected_networks", runtime.ParamLocationQuery, *params.DeleteConnectedNetworks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseByUuidRequest generates requests for GetDatabaseByUuid
func NewGetDatabaseByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabaseByUuidRequest calls the generic UpdateDatabaseByUuid builder with application/json body
func NewUpdateDatabaseByUuidRequest(server string, uuid string, body UpdateDatabaseByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabaseByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateDatabaseByUuidRequestWithBody generates requests for UpdateDatabaseByUuid with any type of body
func NewUpdateDatabaseByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestartDatabaseByUuidRequest generates requests for RestartDatabaseByUuid
func NewRestartDatabaseByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartDatabaseByUuidRequest generates requests for StartDatabaseByUuid
func NewStartDatabaseByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopDatabaseByUuidRequest generates requests for StopDatabaseByUuid
func NewStopDatabaseByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeployByTagOrUuidRequest generates requests for DeployByTagOrUuid
func NewDeployByTagOrUuidRequest(server string, params *DeployByTagOrUuidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deploy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uuid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uuid", runtime.ParamLocationQuery, *params.Uuid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentsRequest generates requests for ListDeployments
func NewListDeploymentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentByUuidRequest generates requests for GetDeploymentByUuid
func NewGetDeploymentByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableApiRequest generates requests for DisableApi
func NewDisableApiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableApiRequest generates requests for EnableApi
func NewEnableApiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthcheckRequest generates requests for Healthcheck
func NewHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectByUuidRequest generates requests for DeleteProjectByUuid
func NewDeleteProjectByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectByUuidRequest generates requests for GetProjectByUuid
func NewGetProjectByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectByUuidRequest calls the generic UpdateProjectByUuid builder with application/json body
func NewUpdateProjectByUuidRequest(server string, uuid string, body UpdateProjectByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateProjectByUuidRequestWithBody generates requests for UpdateProjectByUuid with any type of body
func NewUpdateProjectByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentByNameOrUuidRequest generates requests for GetEnvironmentByNameOrUuid
func NewGetEnvironmentByNameOrUuidRequest(server string, uuid string, environmentNameOrUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_name_or_uuid", runtime.ParamLocationPath, environmentNameOrUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourcesRequest generates requests for ListResources
func NewListResourcesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPrivateKeysRequest generates requests for ListPrivateKeys
func NewListPrivateKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePrivateKeyRequest calls the generic CreatePrivateKey builder with application/json body
func NewCreatePrivateKeyRequest(server string, body CreatePrivateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePrivateKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePrivateKeyRequestWithBody generates requests for CreatePrivateKey with any type of body
func NewCreatePrivateKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePrivateKeyByUuidRequest generates requests for DeletePrivateKeyByUuid
func NewDeletePrivateKeyByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrivateKeyByUuidRequest generates requests for GetPrivateKeyByUuid
func NewGetPrivateKeyByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePrivateKeyRequest calls the generic UpdatePrivateKey builder with application/json body
func NewUpdatePrivateKeyRequest(server string, uuid string, body UpdatePrivateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePrivateKeyRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdatePrivateKeyRequestWithBody generates requests for UpdatePrivateKey with any type of body
func NewUpdatePrivateKeyRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServersRequest generates requests for ListServers
func NewListServersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerRequest calls the generic CreateServer builder with application/json body
func NewCreateServerRequest(server string, body CreateServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServerRequestWithBody generates requests for CreateServer with any type of body
func NewCreateServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerByUuidRequest generates requests for DeleteServerByUuid
func NewDeleteServerByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerByUuidRequest generates requests for GetServerByUuid
func NewGetServerByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServerByUuidRequest calls the generic UpdateServerByUuid builder with application/json body
func NewUpdateServerByUuidRequest(server string, uuid string, body UpdateServerByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServerByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateServerByUuidRequestWithBody generates requests for UpdateServerByUuid with any type of body
func NewUpdateServerByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDomainsByServerUuidRequest generates requests for GetDomainsByServerUuid
func NewGetDomainsByServerUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers/%s/domains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesByServerUuidRequest generates requests for GetResourcesByServerUuid
func NewGetResourcesByServerUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateServerByUuidRequest generates requests for ValidateServerByUuid
func NewValidateServerByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/servers/%s/validate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServicesRequest generates requests for ListServices
func NewListServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceRequest calls the generic CreateService builder with application/json body
func NewCreateServiceRequest(server string, body CreateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServiceRequestWithBody generates requests for CreateService with any type of body
func NewCreateServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceByUuidRequest generates requests for DeleteServiceByUuid
func NewDeleteServiceByUuidRequest(server string, uuid string, params *DeleteServiceByUuidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteConfigurations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_configurations", runtime.ParamLocationQuery, *params.DeleteConfigurations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteVolumes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_volumes", runtime.ParamLocationQuery, *params.DeleteVolumes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DockerCleanup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "docker_cleanup", runtime.ParamLocationQuery, *params.DockerCleanup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteConnectedNetworks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_connected_networks", runtime.ParamLocationQuery, *params.DeleteConnectedNetworks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceByUuidRequest generates requests for GetServiceByUuid
func NewGetServiceByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEnvsByServiceUuidRequest generates requests for ListEnvsByServiceUuid
func NewListEnvsByServiceUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/envs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnvByServiceUuidRequest calls the generic UpdateEnvByServiceUuid builder with application/json body
func NewUpdateEnvByServiceUuidRequest(server string, uuid string, body UpdateEnvByServiceUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvByServiceUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateEnvByServiceUuidRequestWithBody generates requests for UpdateEnvByServiceUuid with any type of body
func NewUpdateEnvByServiceUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/envs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEnvByServiceUuidRequest calls the generic CreateEnvByServiceUuid builder with application/json body
func NewCreateEnvByServiceUuidRequest(server string, uuid string, body CreateEnvByServiceUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvByServiceUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewCreateEnvByServiceUuidRequestWithBody generates requests for CreateEnvByServiceUuid with any type of body
func NewCreateEnvByServiceUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/envs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEnvsByServiceUuidRequest calls the generic UpdateEnvsByServiceUuid builder with application/json body
func NewUpdateEnvsByServiceUuidRequest(server string, uuid string, body UpdateEnvsByServiceUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvsByServiceUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateEnvsByServiceUuidRequestWithBody generates requests for UpdateEnvsByServiceUuid with any type of body
func NewUpdateEnvsByServiceUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/envs/bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvByServiceUuidRequest generates requests for DeleteEnvByServiceUuid
func NewDeleteEnvByServiceUuidRequest(server string, uuid string, envUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "env_uuid", runtime.ParamLocationPath, envUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/envs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartServiceByUuidRequest generates requests for RestartServiceByUuid
func NewRestartServiceByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartServiceByUuidRequest generates requests for StartServiceByUuid
func NewStartServiceByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopServiceByUuidRequest generates requests for StopServiceByUuid
func NewStopServiceByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentTeamRequest generates requests for GetCurrentTeam
func NewGetCurrentTeamRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentTeamMembersRequest generates requests for GetCurrentTeamMembers
func NewGetCurrentTeamMembersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/current/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamByIdRequest generates requests for GetTeamById
func NewGetTeamByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMembersByTeamIdRequest generates requests for GetMembersByTeamId
func NewGetMembersByTeamIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionRequest generates requests for Version
func NewVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListApplicationsWithResponse request
	ListApplicationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListApplicationsResponse, error)

	// CreateDockercomposeApplicationWithBodyWithResponse request with any body
	CreateDockercomposeApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDockercomposeApplicationResponse, error)

	CreateDockercomposeApplicationWithResponse(ctx context.Context, body CreateDockercomposeApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDockercomposeApplicationResponse, error)

	// CreateDockerfileApplicationWithBodyWithResponse request with any body
	CreateDockerfileApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDockerfileApplicationResponse, error)

	CreateDockerfileApplicationWithResponse(ctx context.Context, body CreateDockerfileApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDockerfileApplicationResponse, error)

	// CreateDockerimageApplicationWithBodyWithResponse request with any body
	CreateDockerimageApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDockerimageApplicationResponse, error)

	CreateDockerimageApplicationWithResponse(ctx context.Context, body CreateDockerimageApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDockerimageApplicationResponse, error)

	// CreatePrivateDeployKeyApplicationWithBodyWithResponse request with any body
	CreatePrivateDeployKeyApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateDeployKeyApplicationResponse, error)

	CreatePrivateDeployKeyApplicationWithResponse(ctx context.Context, body CreatePrivateDeployKeyApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateDeployKeyApplicationResponse, error)

	// CreatePrivateGithubAppApplicationWithBodyWithResponse request with any body
	CreatePrivateGithubAppApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateGithubAppApplicationResponse, error)

	CreatePrivateGithubAppApplicationWithResponse(ctx context.Context, body CreatePrivateGithubAppApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateGithubAppApplicationResponse, error)

	// CreatePublicApplicationWithBodyWithResponse request with any body
	CreatePublicApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicApplicationResponse, error)

	CreatePublicApplicationWithResponse(ctx context.Context, body CreatePublicApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicApplicationResponse, error)

	// DeleteApplicationByUuidWithResponse request
	DeleteApplicationByUuidWithResponse(ctx context.Context, uuid string, params *DeleteApplicationByUuidParams, reqEditors ...RequestEditorFn) (*DeleteApplicationByUuidResponse, error)

	// GetApplicationByUuidWithResponse request
	GetApplicationByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetApplicationByUuidResponse, error)

	// UpdateApplicationByUuidWithBodyWithResponse request with any body
	UpdateApplicationByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationByUuidResponse, error)

	UpdateApplicationByUuidWithResponse(ctx context.Context, uuid string, body UpdateApplicationByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationByUuidResponse, error)

	// ListEnvsByApplicationUuidWithResponse request
	ListEnvsByApplicationUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*ListEnvsByApplicationUuidResponse, error)

	// UpdateEnvByApplicationUuidWithBodyWithResponse request with any body
	UpdateEnvByApplicationUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvByApplicationUuidResponse, error)

	UpdateEnvByApplicationUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvByApplicationUuidResponse, error)

	// CreateEnvByApplicationUuidWithBodyWithResponse request with any body
	CreateEnvByApplicationUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvByApplicationUuidResponse, error)

	CreateEnvByApplicationUuidWithResponse(ctx context.Context, uuid string, body CreateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvByApplicationUuidResponse, error)

	// UpdateEnvsByApplicationUuidWithBodyWithResponse request with any body
	UpdateEnvsByApplicationUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvsByApplicationUuidResponse, error)

	UpdateEnvsByApplicationUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvsByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvsByApplicationUuidResponse, error)

	// DeleteEnvByApplicationUuidWithResponse request
	DeleteEnvByApplicationUuidWithResponse(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*DeleteEnvByApplicationUuidResponse, error)

	// ExecuteCommandApplicationWithBodyWithResponse request with any body
	ExecuteCommandApplicationWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteCommandApplicationResponse, error)

	ExecuteCommandApplicationWithResponse(ctx context.Context, uuid string, body ExecuteCommandApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteCommandApplicationResponse, error)

	// RestartApplicationByUuidWithResponse request
	RestartApplicationByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*RestartApplicationByUuidResponse, error)

	// StartApplicationByUuidWithResponse request
	StartApplicationByUuidWithResponse(ctx context.Context, uuid string, params *StartApplicationByUuidParams, reqEditors ...RequestEditorFn) (*StartApplicationByUuidResponse, error)

	// StopApplicationByUuidWithResponse request
	StopApplicationByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StopApplicationByUuidResponse, error)

	// ListDatabasesWithResponse request
	ListDatabasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error)

	// CreateDatabaseClickhouseWithBodyWithResponse request with any body
	CreateDatabaseClickhouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseClickhouseResponse, error)

	CreateDatabaseClickhouseWithResponse(ctx context.Context, body CreateDatabaseClickhouseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseClickhouseResponse, error)

	// CreateDatabaseDragonflyWithBodyWithResponse request with any body
	CreateDatabaseDragonflyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseDragonflyResponse, error)

	CreateDatabaseDragonflyWithResponse(ctx context.Context, body CreateDatabaseDragonflyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseDragonflyResponse, error)

	// CreateDatabaseKeydbWithBodyWithResponse request with any body
	CreateDatabaseKeydbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseKeydbResponse, error)

	CreateDatabaseKeydbWithResponse(ctx context.Context, body CreateDatabaseKeydbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseKeydbResponse, error)

	// CreateDatabaseMariadbWithBodyWithResponse request with any body
	CreateDatabaseMariadbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseMariadbResponse, error)

	CreateDatabaseMariadbWithResponse(ctx context.Context, body CreateDatabaseMariadbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseMariadbResponse, error)

	// CreateDatabaseMongodbWithBodyWithResponse request with any body
	CreateDatabaseMongodbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseMongodbResponse, error)

	CreateDatabaseMongodbWithResponse(ctx context.Context, body CreateDatabaseMongodbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseMongodbResponse, error)

	// CreateDatabaseMysqlWithBodyWithResponse request with any body
	CreateDatabaseMysqlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseMysqlResponse, error)

	CreateDatabaseMysqlWithResponse(ctx context.Context, body CreateDatabaseMysqlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseMysqlResponse, error)

	// CreateDatabasePostgresqlWithBodyWithResponse request with any body
	CreateDatabasePostgresqlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabasePostgresqlResponse, error)

	CreateDatabasePostgresqlWithResponse(ctx context.Context, body CreateDatabasePostgresqlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabasePostgresqlResponse, error)

	// CreateDatabaseRedisWithBodyWithResponse request with any body
	CreateDatabaseRedisWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseRedisResponse, error)

	CreateDatabaseRedisWithResponse(ctx context.Context, body CreateDatabaseRedisJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseRedisResponse, error)

	// DeleteDatabaseByUuidWithResponse request
	DeleteDatabaseByUuidWithResponse(ctx context.Context, uuid string, params *DeleteDatabaseByUuidParams, reqEditors ...RequestEditorFn) (*DeleteDatabaseByUuidResponse, error)

	// GetDatabaseByUuidWithResponse request
	GetDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetDatabaseByUuidResponse, error)

	// UpdateDatabaseByUuidWithBodyWithResponse request with any body
	UpdateDatabaseByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseByUuidResponse, error)

	UpdateDatabaseByUuidWithResponse(ctx context.Context, uuid string, body UpdateDatabaseByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseByUuidResponse, error)

	// RestartDatabaseByUuidWithResponse request
	RestartDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*RestartDatabaseByUuidResponse, error)

	// StartDatabaseByUuidWithResponse request
	StartDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StartDatabaseByUuidResponse, error)

	// StopDatabaseByUuidWithResponse request
	StopDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StopDatabaseByUuidResponse, error)

	// DeployByTagOrUuidWithResponse request
	DeployByTagOrUuidWithResponse(ctx context.Context, params *DeployByTagOrUuidParams, reqEditors ...RequestEditorFn) (*DeployByTagOrUuidResponse, error)

	// ListDeploymentsWithResponse request
	ListDeploymentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error)

	// GetDeploymentByUuidWithResponse request
	GetDeploymentByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetDeploymentByUuidResponse, error)

	// DisableApiWithResponse request
	DisableApiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableApiResponse, error)

	// EnableApiWithResponse request
	EnableApiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EnableApiResponse, error)

	// HealthcheckWithResponse request
	HealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthcheckResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProjectByUuidWithResponse request
	DeleteProjectByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*DeleteProjectByUuidResponse, error)

	// GetProjectByUuidWithResponse request
	GetProjectByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetProjectByUuidResponse, error)

	// UpdateProjectByUuidWithBodyWithResponse request with any body
	UpdateProjectByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectByUuidResponse, error)

	UpdateProjectByUuidWithResponse(ctx context.Context, uuid string, body UpdateProjectByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectByUuidResponse, error)

	// GetEnvironmentByNameOrUuidWithResponse request
	GetEnvironmentByNameOrUuidWithResponse(ctx context.Context, uuid string, environmentNameOrUuid string, reqEditors ...RequestEditorFn) (*GetEnvironmentByNameOrUuidResponse, error)

	// ListResourcesWithResponse request
	ListResourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResourcesResponse, error)

	// ListPrivateKeysWithResponse request
	ListPrivateKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPrivateKeysResponse, error)

	// CreatePrivateKeyWithBodyWithResponse request with any body
	CreatePrivateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateKeyResponse, error)

	CreatePrivateKeyWithResponse(ctx context.Context, body CreatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateKeyResponse, error)

	// DeletePrivateKeyByUuidWithResponse request
	DeletePrivateKeyByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*DeletePrivateKeyByUuidResponse, error)

	// GetPrivateKeyByUuidWithResponse request
	GetPrivateKeyByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetPrivateKeyByUuidResponse, error)

	// UpdatePrivateKeyWithBodyWithResponse request with any body
	UpdatePrivateKeyWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePrivateKeyResponse, error)

	UpdatePrivateKeyWithResponse(ctx context.Context, uuid string, body UpdatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePrivateKeyResponse, error)

	// ListServersWithResponse request
	ListServersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListServersResponse, error)

	// CreateServerWithBodyWithResponse request with any body
	CreateServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerResponse, error)

	CreateServerWithResponse(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerResponse, error)

	// DeleteServerByUuidWithResponse request
	DeleteServerByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*DeleteServerByUuidResponse, error)

	// GetServerByUuidWithResponse request
	GetServerByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetServerByUuidResponse, error)

	// UpdateServerByUuidWithBodyWithResponse request with any body
	UpdateServerByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerByUuidResponse, error)

	UpdateServerByUuidWithResponse(ctx context.Context, uuid string, body UpdateServerByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerByUuidResponse, error)

	// GetDomainsByServerUuidWithResponse request
	GetDomainsByServerUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetDomainsByServerUuidResponse, error)

	// GetResourcesByServerUuidWithResponse request
	GetResourcesByServerUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetResourcesByServerUuidResponse, error)

	// ValidateServerByUuidWithResponse request
	ValidateServerByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*ValidateServerByUuidResponse, error)

	// ListServicesWithResponse request
	ListServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListServicesResponse, error)

	// CreateServiceWithBodyWithResponse request with any body
	CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	// DeleteServiceByUuidWithResponse request
	DeleteServiceByUuidWithResponse(ctx context.Context, uuid string, params *DeleteServiceByUuidParams, reqEditors ...RequestEditorFn) (*DeleteServiceByUuidResponse, error)

	// GetServiceByUuidWithResponse request
	GetServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetServiceByUuidResponse, error)

	// ListEnvsByServiceUuidWithResponse request
	ListEnvsByServiceUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*ListEnvsByServiceUuidResponse, error)

	// UpdateEnvByServiceUuidWithBodyWithResponse request with any body
	UpdateEnvByServiceUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvByServiceUuidResponse, error)

	UpdateEnvByServiceUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvByServiceUuidResponse, error)

	// CreateEnvByServiceUuidWithBodyWithResponse request with any body
	CreateEnvByServiceUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvByServiceUuidResponse, error)

	CreateEnvByServiceUuidWithResponse(ctx context.Context, uuid string, body CreateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvByServiceUuidResponse, error)

	// UpdateEnvsByServiceUuidWithBodyWithResponse request with any body
	UpdateEnvsByServiceUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvsByServiceUuidResponse, error)

	UpdateEnvsByServiceUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvsByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvsByServiceUuidResponse, error)

	// DeleteEnvByServiceUuidWithResponse request
	DeleteEnvByServiceUuidWithResponse(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*DeleteEnvByServiceUuidResponse, error)

	// RestartServiceByUuidWithResponse request
	RestartServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*RestartServiceByUuidResponse, error)

	// StartServiceByUuidWithResponse request
	StartServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StartServiceByUuidResponse, error)

	// StopServiceByUuidWithResponse request
	StopServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StopServiceByUuidResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// GetCurrentTeamWithResponse request
	GetCurrentTeamWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentTeamResponse, error)

	// GetCurrentTeamMembersWithResponse request
	GetCurrentTeamMembersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentTeamMembersResponse, error)

	// GetTeamByIdWithResponse request
	GetTeamByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamByIdResponse, error)

	// GetMembersByTeamIdWithResponse request
	GetMembersByTeamIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMembersByTeamIdResponse, error)

	// VersionWithResponse request
	VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error)
}

type ListApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Application
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDockercomposeApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateDockercomposeApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDockercomposeApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDockerfileApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateDockerfileApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDockerfileApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDockerimageApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateDockerimageApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDockerimageApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePrivateDeployKeyApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreatePrivateDeployKeyApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePrivateDeployKeyApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePrivateGithubAppApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreatePrivateGithubAppApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePrivateGithubAppApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreatePublicApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApplicationByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteApplicationByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApplicationByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetApplicationByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateApplicationByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r UpdateApplicationByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApplicationByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvsByApplicationUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnvironmentVariable
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListEnvsByApplicationUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvsByApplicationUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvByApplicationUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r UpdateEnvByApplicationUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvByApplicationUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvByApplicationUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r CreateEnvByApplicationUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvByApplicationUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvsByApplicationUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]EnvironmentVariable
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateEnvsByApplicationUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvsByApplicationUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvByApplicationUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteEnvByApplicationUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvByApplicationUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteCommandApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message  *string `json:"message,omitempty"`
		Response *string `json:"response,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ExecuteCommandApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteCommandApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartApplicationByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeploymentUuid UUID of the deployment.
		DeploymentUuid *string `json:"deployment_uuid,omitempty"`
		Message        *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r RestartApplicationByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartApplicationByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartApplicationByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeploymentUuid UUID of the deployment.
		DeploymentUuid *string `json:"deployment_uuid,omitempty"`

		// Message Message.
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r StartApplicationByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartApplicationByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopApplicationByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r StopApplicationByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopApplicationByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Database
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseClickhouseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseClickhouseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseClickhouseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseDragonflyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseDragonflyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseDragonflyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseKeydbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseKeydbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseKeydbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseMariadbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseMariadbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseMariadbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseMongodbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseMongodbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseMongodbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseMysqlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		InternalDbUrl string `json:"internal_db_url"`
		Uuid          string `json:"uuid"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseMysqlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseMysqlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabasePostgresqlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		InternalDbUrl string `json:"internal_db_url"`
		Uuid          string `json:"uuid"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabasePostgresqlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabasePostgresqlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseRedisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseRedisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseRedisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabaseByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteDatabaseByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabaseByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetDatabaseByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatabaseByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateDatabaseByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatabaseByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartDatabaseByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r RestartDatabaseByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartDatabaseByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartDatabaseByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r StartDatabaseByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartDatabaseByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopDatabaseByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r StopDatabaseByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopDatabaseByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployByTagOrUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Deployments *[]struct {
			DeploymentUuid *string `json:"deployment_uuid,omitempty"`
			Message        *string `json:"message,omitempty"`
			ResourceUuid   *string `json:"resource_uuid,omitempty"`
		} `json:"deployments,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeployByTagOrUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployByTagOrUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApplicationDeploymentQueue
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationDeploymentQueue
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetDeploymentByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableApiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DisableApiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableApiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableApiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableApiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableApiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r HealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Project
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Uuid The UUID of the project.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteProjectByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r GetProjectByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Description *string `json:"description,omitempty"`
		Name        *string `json:"name,omitempty"`
		Uuid        *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r UpdateProjectByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentByNameOrUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentByNameOrUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentByNameOrUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrivateKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PrivateKey
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListPrivateKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrivateKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePrivateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreatePrivateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePrivateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePrivateKeyByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeletePrivateKeyByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePrivateKeyByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateKeyByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateKey
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r GetPrivateKeyByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateKeyByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePrivateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdatePrivateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePrivateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Server
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Uuid The UUID of the server.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r CreateServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteServerByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetServerByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServerByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateServerByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServerByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainsByServerUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Domains *[]string `json:"domains,omitempty"`
		Ip      *string   `json:"ip,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r GetDomainsByServerUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainsByServerUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesByServerUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CreatedAt *string `json:"created_at,omitempty"`
		Id        *int    `json:"id,omitempty"`
		Name      *string `json:"name,omitempty"`
		Status    *string `json:"status,omitempty"`
		Type      *string `json:"type,omitempty"`
		UpdatedAt *string `json:"updated_at,omitempty"`
		Uuid      *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r GetResourcesByServerUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesByServerUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateServerByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ValidateServerByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateServerByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Service
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Domains Service domains.
		Domains *[]string `json:"domains,omitempty"`

		// Uuid Service UUID.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteServiceByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetServiceByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvsByServiceUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnvironmentVariable
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListEnvsByServiceUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvsByServiceUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvByServiceUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r UpdateEnvByServiceUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvByServiceUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvByServiceUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r CreateEnvByServiceUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvByServiceUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvsByServiceUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]EnvironmentVariable
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateEnvsByServiceUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvsByServiceUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvByServiceUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r DeleteEnvByServiceUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvByServiceUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartServiceByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r RestartServiceByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartServiceByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartServiceByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r StartServiceByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartServiceByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopServiceByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r StopServiceByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopServiceByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r GetCurrentTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentTeamMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r GetCurrentTeamMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentTeamMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetTeamByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMembersByTeamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetMembersByTeamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMembersByTeamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r VersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListApplicationsWithResponse request returning *ListApplicationsResponse
func (c *ClientWithResponses) ListApplicationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListApplicationsResponse, error) {
	rsp, err := c.ListApplications(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationsResponse(rsp)
}

// CreateDockercomposeApplicationWithBodyWithResponse request with arbitrary body returning *CreateDockercomposeApplicationResponse
func (c *ClientWithResponses) CreateDockercomposeApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDockercomposeApplicationResponse, error) {
	rsp, err := c.CreateDockercomposeApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDockercomposeApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreateDockercomposeApplicationWithResponse(ctx context.Context, body CreateDockercomposeApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDockercomposeApplicationResponse, error) {
	rsp, err := c.CreateDockercomposeApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDockercomposeApplicationResponse(rsp)
}

// CreateDockerfileApplicationWithBodyWithResponse request with arbitrary body returning *CreateDockerfileApplicationResponse
func (c *ClientWithResponses) CreateDockerfileApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDockerfileApplicationResponse, error) {
	rsp, err := c.CreateDockerfileApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDockerfileApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreateDockerfileApplicationWithResponse(ctx context.Context, body CreateDockerfileApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDockerfileApplicationResponse, error) {
	rsp, err := c.CreateDockerfileApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDockerfileApplicationResponse(rsp)
}

// CreateDockerimageApplicationWithBodyWithResponse request with arbitrary body returning *CreateDockerimageApplicationResponse
func (c *ClientWithResponses) CreateDockerimageApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDockerimageApplicationResponse, error) {
	rsp, err := c.CreateDockerimageApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDockerimageApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreateDockerimageApplicationWithResponse(ctx context.Context, body CreateDockerimageApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDockerimageApplicationResponse, error) {
	rsp, err := c.CreateDockerimageApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDockerimageApplicationResponse(rsp)
}

// CreatePrivateDeployKeyApplicationWithBodyWithResponse request with arbitrary body returning *CreatePrivateDeployKeyApplicationResponse
func (c *ClientWithResponses) CreatePrivateDeployKeyApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateDeployKeyApplicationResponse, error) {
	rsp, err := c.CreatePrivateDeployKeyApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateDeployKeyApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreatePrivateDeployKeyApplicationWithResponse(ctx context.Context, body CreatePrivateDeployKeyApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateDeployKeyApplicationResponse, error) {
	rsp, err := c.CreatePrivateDeployKeyApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateDeployKeyApplicationResponse(rsp)
}

// CreatePrivateGithubAppApplicationWithBodyWithResponse request with arbitrary body returning *CreatePrivateGithubAppApplicationResponse
func (c *ClientWithResponses) CreatePrivateGithubAppApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateGithubAppApplicationResponse, error) {
	rsp, err := c.CreatePrivateGithubAppApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateGithubAppApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreatePrivateGithubAppApplicationWithResponse(ctx context.Context, body CreatePrivateGithubAppApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateGithubAppApplicationResponse, error) {
	rsp, err := c.CreatePrivateGithubAppApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateGithubAppApplicationResponse(rsp)
}

// CreatePublicApplicationWithBodyWithResponse request with arbitrary body returning *CreatePublicApplicationResponse
func (c *ClientWithResponses) CreatePublicApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicApplicationResponse, error) {
	rsp, err := c.CreatePublicApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreatePublicApplicationWithResponse(ctx context.Context, body CreatePublicApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicApplicationResponse, error) {
	rsp, err := c.CreatePublicApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicApplicationResponse(rsp)
}

// DeleteApplicationByUuidWithResponse request returning *DeleteApplicationByUuidResponse
func (c *ClientWithResponses) DeleteApplicationByUuidWithResponse(ctx context.Context, uuid string, params *DeleteApplicationByUuidParams, reqEditors ...RequestEditorFn) (*DeleteApplicationByUuidResponse, error) {
	rsp, err := c.DeleteApplicationByUuid(ctx, uuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApplicationByUuidResponse(rsp)
}

// GetApplicationByUuidWithResponse request returning *GetApplicationByUuidResponse
func (c *ClientWithResponses) GetApplicationByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetApplicationByUuidResponse, error) {
	rsp, err := c.GetApplicationByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationByUuidResponse(rsp)
}

// UpdateApplicationByUuidWithBodyWithResponse request with arbitrary body returning *UpdateApplicationByUuidResponse
func (c *ClientWithResponses) UpdateApplicationByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationByUuidResponse, error) {
	rsp, err := c.UpdateApplicationByUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateApplicationByUuidWithResponse(ctx context.Context, uuid string, body UpdateApplicationByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationByUuidResponse, error) {
	rsp, err := c.UpdateApplicationByUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationByUuidResponse(rsp)
}

// ListEnvsByApplicationUuidWithResponse request returning *ListEnvsByApplicationUuidResponse
func (c *ClientWithResponses) ListEnvsByApplicationUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*ListEnvsByApplicationUuidResponse, error) {
	rsp, err := c.ListEnvsByApplicationUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnvsByApplicationUuidResponse(rsp)
}

// UpdateEnvByApplicationUuidWithBodyWithResponse request with arbitrary body returning *UpdateEnvByApplicationUuidResponse
func (c *ClientWithResponses) UpdateEnvByApplicationUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvByApplicationUuidResponse, error) {
	rsp, err := c.UpdateEnvByApplicationUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvByApplicationUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvByApplicationUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvByApplicationUuidResponse, error) {
	rsp, err := c.UpdateEnvByApplicationUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvByApplicationUuidResponse(rsp)
}

// CreateEnvByApplicationUuidWithBodyWithResponse request with arbitrary body returning *CreateEnvByApplicationUuidResponse
func (c *ClientWithResponses) CreateEnvByApplicationUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvByApplicationUuidResponse, error) {
	rsp, err := c.CreateEnvByApplicationUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvByApplicationUuidResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvByApplicationUuidWithResponse(ctx context.Context, uuid string, body CreateEnvByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvByApplicationUuidResponse, error) {
	rsp, err := c.CreateEnvByApplicationUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvByApplicationUuidResponse(rsp)
}

// UpdateEnvsByApplicationUuidWithBodyWithResponse request with arbitrary body returning *UpdateEnvsByApplicationUuidResponse
func (c *ClientWithResponses) UpdateEnvsByApplicationUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvsByApplicationUuidResponse, error) {
	rsp, err := c.UpdateEnvsByApplicationUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvsByApplicationUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvsByApplicationUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvsByApplicationUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvsByApplicationUuidResponse, error) {
	rsp, err := c.UpdateEnvsByApplicationUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvsByApplicationUuidResponse(rsp)
}

// DeleteEnvByApplicationUuidWithResponse request returning *DeleteEnvByApplicationUuidResponse
func (c *ClientWithResponses) DeleteEnvByApplicationUuidWithResponse(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*DeleteEnvByApplicationUuidResponse, error) {
	rsp, err := c.DeleteEnvByApplicationUuid(ctx, uuid, envUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvByApplicationUuidResponse(rsp)
}

// ExecuteCommandApplicationWithBodyWithResponse request with arbitrary body returning *ExecuteCommandApplicationResponse
func (c *ClientWithResponses) ExecuteCommandApplicationWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteCommandApplicationResponse, error) {
	rsp, err := c.ExecuteCommandApplicationWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteCommandApplicationResponse(rsp)
}

func (c *ClientWithResponses) ExecuteCommandApplicationWithResponse(ctx context.Context, uuid string, body ExecuteCommandApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteCommandApplicationResponse, error) {
	rsp, err := c.ExecuteCommandApplication(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteCommandApplicationResponse(rsp)
}

// RestartApplicationByUuidWithResponse request returning *RestartApplicationByUuidResponse
func (c *ClientWithResponses) RestartApplicationByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*RestartApplicationByUuidResponse, error) {
	rsp, err := c.RestartApplicationByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartApplicationByUuidResponse(rsp)
}

// StartApplicationByUuidWithResponse request returning *StartApplicationByUuidResponse
func (c *ClientWithResponses) StartApplicationByUuidWithResponse(ctx context.Context, uuid string, params *StartApplicationByUuidParams, reqEditors ...RequestEditorFn) (*StartApplicationByUuidResponse, error) {
	rsp, err := c.StartApplicationByUuid(ctx, uuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartApplicationByUuidResponse(rsp)
}

// StopApplicationByUuidWithResponse request returning *StopApplicationByUuidResponse
func (c *ClientWithResponses) StopApplicationByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StopApplicationByUuidResponse, error) {
	rsp, err := c.StopApplicationByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopApplicationByUuidResponse(rsp)
}

// ListDatabasesWithResponse request returning *ListDatabasesResponse
func (c *ClientWithResponses) ListDatabasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error) {
	rsp, err := c.ListDatabases(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabasesResponse(rsp)
}

// CreateDatabaseClickhouseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseClickhouseResponse
func (c *ClientWithResponses) CreateDatabaseClickhouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseClickhouseResponse, error) {
	rsp, err := c.CreateDatabaseClickhouseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseClickhouseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseClickhouseWithResponse(ctx context.Context, body CreateDatabaseClickhouseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseClickhouseResponse, error) {
	rsp, err := c.CreateDatabaseClickhouse(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseClickhouseResponse(rsp)
}

// CreateDatabaseDragonflyWithBodyWithResponse request with arbitrary body returning *CreateDatabaseDragonflyResponse
func (c *ClientWithResponses) CreateDatabaseDragonflyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseDragonflyResponse, error) {
	rsp, err := c.CreateDatabaseDragonflyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseDragonflyResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseDragonflyWithResponse(ctx context.Context, body CreateDatabaseDragonflyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseDragonflyResponse, error) {
	rsp, err := c.CreateDatabaseDragonfly(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseDragonflyResponse(rsp)
}

// CreateDatabaseKeydbWithBodyWithResponse request with arbitrary body returning *CreateDatabaseKeydbResponse
func (c *ClientWithResponses) CreateDatabaseKeydbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseKeydbResponse, error) {
	rsp, err := c.CreateDatabaseKeydbWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseKeydbResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseKeydbWithResponse(ctx context.Context, body CreateDatabaseKeydbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseKeydbResponse, error) {
	rsp, err := c.CreateDatabaseKeydb(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseKeydbResponse(rsp)
}

// CreateDatabaseMariadbWithBodyWithResponse request with arbitrary body returning *CreateDatabaseMariadbResponse
func (c *ClientWithResponses) CreateDatabaseMariadbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseMariadbResponse, error) {
	rsp, err := c.CreateDatabaseMariadbWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseMariadbResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseMariadbWithResponse(ctx context.Context, body CreateDatabaseMariadbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseMariadbResponse, error) {
	rsp, err := c.CreateDatabaseMariadb(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseMariadbResponse(rsp)
}

// CreateDatabaseMongodbWithBodyWithResponse request with arbitrary body returning *CreateDatabaseMongodbResponse
func (c *ClientWithResponses) CreateDatabaseMongodbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseMongodbResponse, error) {
	rsp, err := c.CreateDatabaseMongodbWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseMongodbResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseMongodbWithResponse(ctx context.Context, body CreateDatabaseMongodbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseMongodbResponse, error) {
	rsp, err := c.CreateDatabaseMongodb(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseMongodbResponse(rsp)
}

// CreateDatabaseMysqlWithBodyWithResponse request with arbitrary body returning *CreateDatabaseMysqlResponse
func (c *ClientWithResponses) CreateDatabaseMysqlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseMysqlResponse, error) {
	rsp, err := c.CreateDatabaseMysqlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseMysqlResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseMysqlWithResponse(ctx context.Context, body CreateDatabaseMysqlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseMysqlResponse, error) {
	rsp, err := c.CreateDatabaseMysql(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseMysqlResponse(rsp)
}

// CreateDatabasePostgresqlWithBodyWithResponse request with arbitrary body returning *CreateDatabasePostgresqlResponse
func (c *ClientWithResponses) CreateDatabasePostgresqlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabasePostgresqlResponse, error) {
	rsp, err := c.CreateDatabasePostgresqlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabasePostgresqlResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabasePostgresqlWithResponse(ctx context.Context, body CreateDatabasePostgresqlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabasePostgresqlResponse, error) {
	rsp, err := c.CreateDatabasePostgresql(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabasePostgresqlResponse(rsp)
}

// CreateDatabaseRedisWithBodyWithResponse request with arbitrary body returning *CreateDatabaseRedisResponse
func (c *ClientWithResponses) CreateDatabaseRedisWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseRedisResponse, error) {
	rsp, err := c.CreateDatabaseRedisWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseRedisResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseRedisWithResponse(ctx context.Context, body CreateDatabaseRedisJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseRedisResponse, error) {
	rsp, err := c.CreateDatabaseRedis(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseRedisResponse(rsp)
}

// DeleteDatabaseByUuidWithResponse request returning *DeleteDatabaseByUuidResponse
func (c *ClientWithResponses) DeleteDatabaseByUuidWithResponse(ctx context.Context, uuid string, params *DeleteDatabaseByUuidParams, reqEditors ...RequestEditorFn) (*DeleteDatabaseByUuidResponse, error) {
	rsp, err := c.DeleteDatabaseByUuid(ctx, uuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseByUuidResponse(rsp)
}

// GetDatabaseByUuidWithResponse request returning *GetDatabaseByUuidResponse
func (c *ClientWithResponses) GetDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetDatabaseByUuidResponse, error) {
	rsp, err := c.GetDatabaseByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseByUuidResponse(rsp)
}

// UpdateDatabaseByUuidWithBodyWithResponse request with arbitrary body returning *UpdateDatabaseByUuidResponse
func (c *ClientWithResponses) UpdateDatabaseByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseByUuidResponse, error) {
	rsp, err := c.UpdateDatabaseByUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabaseByUuidWithResponse(ctx context.Context, uuid string, body UpdateDatabaseByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseByUuidResponse, error) {
	rsp, err := c.UpdateDatabaseByUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseByUuidResponse(rsp)
}

// RestartDatabaseByUuidWithResponse request returning *RestartDatabaseByUuidResponse
func (c *ClientWithResponses) RestartDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*RestartDatabaseByUuidResponse, error) {
	rsp, err := c.RestartDatabaseByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartDatabaseByUuidResponse(rsp)
}

// StartDatabaseByUuidWithResponse request returning *StartDatabaseByUuidResponse
func (c *ClientWithResponses) StartDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StartDatabaseByUuidResponse, error) {
	rsp, err := c.StartDatabaseByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartDatabaseByUuidResponse(rsp)
}

// StopDatabaseByUuidWithResponse request returning *StopDatabaseByUuidResponse
func (c *ClientWithResponses) StopDatabaseByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StopDatabaseByUuidResponse, error) {
	rsp, err := c.StopDatabaseByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopDatabaseByUuidResponse(rsp)
}

// DeployByTagOrUuidWithResponse request returning *DeployByTagOrUuidResponse
func (c *ClientWithResponses) DeployByTagOrUuidWithResponse(ctx context.Context, params *DeployByTagOrUuidParams, reqEditors ...RequestEditorFn) (*DeployByTagOrUuidResponse, error) {
	rsp, err := c.DeployByTagOrUuid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployByTagOrUuidResponse(rsp)
}

// ListDeploymentsWithResponse request returning *ListDeploymentsResponse
func (c *ClientWithResponses) ListDeploymentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error) {
	rsp, err := c.ListDeployments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentsResponse(rsp)
}

// GetDeploymentByUuidWithResponse request returning *GetDeploymentByUuidResponse
func (c *ClientWithResponses) GetDeploymentByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetDeploymentByUuidResponse, error) {
	rsp, err := c.GetDeploymentByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentByUuidResponse(rsp)
}

// DisableApiWithResponse request returning *DisableApiResponse
func (c *ClientWithResponses) DisableApiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableApiResponse, error) {
	rsp, err := c.DisableApi(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableApiResponse(rsp)
}

// EnableApiWithResponse request returning *EnableApiResponse
func (c *ClientWithResponses) EnableApiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EnableApiResponse, error) {
	rsp, err := c.EnableApi(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableApiResponse(rsp)
}

// HealthcheckWithResponse request returning *HealthcheckResponse
func (c *ClientWithResponses) HealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthcheckResponse, error) {
	rsp, err := c.Healthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthcheckResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectByUuidWithResponse request returning *DeleteProjectByUuidResponse
func (c *ClientWithResponses) DeleteProjectByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*DeleteProjectByUuidResponse, error) {
	rsp, err := c.DeleteProjectByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectByUuidResponse(rsp)
}

// GetProjectByUuidWithResponse request returning *GetProjectByUuidResponse
func (c *ClientWithResponses) GetProjectByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetProjectByUuidResponse, error) {
	rsp, err := c.GetProjectByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectByUuidResponse(rsp)
}

// UpdateProjectByUuidWithBodyWithResponse request with arbitrary body returning *UpdateProjectByUuidResponse
func (c *ClientWithResponses) UpdateProjectByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectByUuidResponse, error) {
	rsp, err := c.UpdateProjectByUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectByUuidWithResponse(ctx context.Context, uuid string, body UpdateProjectByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectByUuidResponse, error) {
	rsp, err := c.UpdateProjectByUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectByUuidResponse(rsp)
}

// GetEnvironmentByNameOrUuidWithResponse request returning *GetEnvironmentByNameOrUuidResponse
func (c *ClientWithResponses) GetEnvironmentByNameOrUuidWithResponse(ctx context.Context, uuid string, environmentNameOrUuid string, reqEditors ...RequestEditorFn) (*GetEnvironmentByNameOrUuidResponse, error) {
	rsp, err := c.GetEnvironmentByNameOrUuid(ctx, uuid, environmentNameOrUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentByNameOrUuidResponse(rsp)
}

// ListResourcesWithResponse request returning *ListResourcesResponse
func (c *ClientWithResponses) ListResourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResourcesResponse, error) {
	rsp, err := c.ListResources(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourcesResponse(rsp)
}

// ListPrivateKeysWithResponse request returning *ListPrivateKeysResponse
func (c *ClientWithResponses) ListPrivateKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPrivateKeysResponse, error) {
	rsp, err := c.ListPrivateKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrivateKeysResponse(rsp)
}

// CreatePrivateKeyWithBodyWithResponse request with arbitrary body returning *CreatePrivateKeyResponse
func (c *ClientWithResponses) CreatePrivateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateKeyResponse, error) {
	rsp, err := c.CreatePrivateKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateKeyResponse(rsp)
}

func (c *ClientWithResponses) CreatePrivateKeyWithResponse(ctx context.Context, body CreatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateKeyResponse, error) {
	rsp, err := c.CreatePrivateKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateKeyResponse(rsp)
}

// DeletePrivateKeyByUuidWithResponse request returning *DeletePrivateKeyByUuidResponse
func (c *ClientWithResponses) DeletePrivateKeyByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*DeletePrivateKeyByUuidResponse, error) {
	rsp, err := c.DeletePrivateKeyByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePrivateKeyByUuidResponse(rsp)
}

// GetPrivateKeyByUuidWithResponse request returning *GetPrivateKeyByUuidResponse
func (c *ClientWithResponses) GetPrivateKeyByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetPrivateKeyByUuidResponse, error) {
	rsp, err := c.GetPrivateKeyByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateKeyByUuidResponse(rsp)
}

// UpdatePrivateKeyWithBodyWithResponse request with arbitrary body returning *UpdatePrivateKeyResponse
func (c *ClientWithResponses) UpdatePrivateKeyWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePrivateKeyResponse, error) {
	rsp, err := c.UpdatePrivateKeyWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePrivateKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePrivateKeyWithResponse(ctx context.Context, uuid string, body UpdatePrivateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePrivateKeyResponse, error) {
	rsp, err := c.UpdatePrivateKey(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePrivateKeyResponse(rsp)
}

// ListServersWithResponse request returning *ListServersResponse
func (c *ClientWithResponses) ListServersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListServersResponse, error) {
	rsp, err := c.ListServers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServersResponse(rsp)
}

// CreateServerWithBodyWithResponse request with arbitrary body returning *CreateServerResponse
func (c *ClientWithResponses) CreateServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerResponse, error) {
	rsp, err := c.CreateServerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerResponse(rsp)
}

func (c *ClientWithResponses) CreateServerWithResponse(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerResponse, error) {
	rsp, err := c.CreateServer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerResponse(rsp)
}

// DeleteServerByUuidWithResponse request returning *DeleteServerByUuidResponse
func (c *ClientWithResponses) DeleteServerByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*DeleteServerByUuidResponse, error) {
	rsp, err := c.DeleteServerByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerByUuidResponse(rsp)
}

// GetServerByUuidWithResponse request returning *GetServerByUuidResponse
func (c *ClientWithResponses) GetServerByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetServerByUuidResponse, error) {
	rsp, err := c.GetServerByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerByUuidResponse(rsp)
}

// UpdateServerByUuidWithBodyWithResponse request with arbitrary body returning *UpdateServerByUuidResponse
func (c *ClientWithResponses) UpdateServerByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerByUuidResponse, error) {
	rsp, err := c.UpdateServerByUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateServerByUuidWithResponse(ctx context.Context, uuid string, body UpdateServerByUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerByUuidResponse, error) {
	rsp, err := c.UpdateServerByUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerByUuidResponse(rsp)
}

// GetDomainsByServerUuidWithResponse request returning *GetDomainsByServerUuidResponse
func (c *ClientWithResponses) GetDomainsByServerUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetDomainsByServerUuidResponse, error) {
	rsp, err := c.GetDomainsByServerUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainsByServerUuidResponse(rsp)
}

// GetResourcesByServerUuidWithResponse request returning *GetResourcesByServerUuidResponse
func (c *ClientWithResponses) GetResourcesByServerUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetResourcesByServerUuidResponse, error) {
	rsp, err := c.GetResourcesByServerUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesByServerUuidResponse(rsp)
}

// ValidateServerByUuidWithResponse request returning *ValidateServerByUuidResponse
func (c *ClientWithResponses) ValidateServerByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*ValidateServerByUuidResponse, error) {
	rsp, err := c.ValidateServerByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateServerByUuidResponse(rsp)
}

// ListServicesWithResponse request returning *ListServicesResponse
func (c *ClientWithResponses) ListServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListServicesResponse, error) {
	rsp, err := c.ListServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicesResponse(rsp)
}

// CreateServiceWithBodyWithResponse request with arbitrary body returning *CreateServiceResponse
func (c *ClientWithResponses) CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

// DeleteServiceByUuidWithResponse request returning *DeleteServiceByUuidResponse
func (c *ClientWithResponses) DeleteServiceByUuidWithResponse(ctx context.Context, uuid string, params *DeleteServiceByUuidParams, reqEditors ...RequestEditorFn) (*DeleteServiceByUuidResponse, error) {
	rsp, err := c.DeleteServiceByUuid(ctx, uuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceByUuidResponse(rsp)
}

// GetServiceByUuidWithResponse request returning *GetServiceByUuidResponse
func (c *ClientWithResponses) GetServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*GetServiceByUuidResponse, error) {
	rsp, err := c.GetServiceByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceByUuidResponse(rsp)
}

// ListEnvsByServiceUuidWithResponse request returning *ListEnvsByServiceUuidResponse
func (c *ClientWithResponses) ListEnvsByServiceUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*ListEnvsByServiceUuidResponse, error) {
	rsp, err := c.ListEnvsByServiceUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnvsByServiceUuidResponse(rsp)
}

// UpdateEnvByServiceUuidWithBodyWithResponse request with arbitrary body returning *UpdateEnvByServiceUuidResponse
func (c *ClientWithResponses) UpdateEnvByServiceUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvByServiceUuidResponse, error) {
	rsp, err := c.UpdateEnvByServiceUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvByServiceUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvByServiceUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvByServiceUuidResponse, error) {
	rsp, err := c.UpdateEnvByServiceUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvByServiceUuidResponse(rsp)
}

// CreateEnvByServiceUuidWithBodyWithResponse request with arbitrary body returning *CreateEnvByServiceUuidResponse
func (c *ClientWithResponses) CreateEnvByServiceUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvByServiceUuidResponse, error) {
	rsp, err := c.CreateEnvByServiceUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvByServiceUuidResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvByServiceUuidWithResponse(ctx context.Context, uuid string, body CreateEnvByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvByServiceUuidResponse, error) {
	rsp, err := c.CreateEnvByServiceUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvByServiceUuidResponse(rsp)
}

// UpdateEnvsByServiceUuidWithBodyWithResponse request with arbitrary body returning *UpdateEnvsByServiceUuidResponse
func (c *ClientWithResponses) UpdateEnvsByServiceUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvsByServiceUuidResponse, error) {
	rsp, err := c.UpdateEnvsByServiceUuidWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvsByServiceUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvsByServiceUuidWithResponse(ctx context.Context, uuid string, body UpdateEnvsByServiceUuidJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvsByServiceUuidResponse, error) {
	rsp, err := c.UpdateEnvsByServiceUuid(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvsByServiceUuidResponse(rsp)
}

// DeleteEnvByServiceUuidWithResponse request returning *DeleteEnvByServiceUuidResponse
func (c *ClientWithResponses) DeleteEnvByServiceUuidWithResponse(ctx context.Context, uuid string, envUuid string, reqEditors ...RequestEditorFn) (*DeleteEnvByServiceUuidResponse, error) {
	rsp, err := c.DeleteEnvByServiceUuid(ctx, uuid, envUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvByServiceUuidResponse(rsp)
}

// RestartServiceByUuidWithResponse request returning *RestartServiceByUuidResponse
func (c *ClientWithResponses) RestartServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*RestartServiceByUuidResponse, error) {
	rsp, err := c.RestartServiceByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartServiceByUuidResponse(rsp)
}

// StartServiceByUuidWithResponse request returning *StartServiceByUuidResponse
func (c *ClientWithResponses) StartServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StartServiceByUuidResponse, error) {
	rsp, err := c.StartServiceByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartServiceByUuidResponse(rsp)
}

// StopServiceByUuidWithResponse request returning *StopServiceByUuidResponse
func (c *ClientWithResponses) StopServiceByUuidWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*StopServiceByUuidResponse, error) {
	rsp, err := c.StopServiceByUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopServiceByUuidResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// GetCurrentTeamWithResponse request returning *GetCurrentTeamResponse
func (c *ClientWithResponses) GetCurrentTeamWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentTeamResponse, error) {
	rsp, err := c.GetCurrentTeam(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentTeamResponse(rsp)
}

// GetCurrentTeamMembersWithResponse request returning *GetCurrentTeamMembersResponse
func (c *ClientWithResponses) GetCurrentTeamMembersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentTeamMembersResponse, error) {
	rsp, err := c.GetCurrentTeamMembers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentTeamMembersResponse(rsp)
}

// GetTeamByIdWithResponse request returning *GetTeamByIdResponse
func (c *ClientWithResponses) GetTeamByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamByIdResponse, error) {
	rsp, err := c.GetTeamById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamByIdResponse(rsp)
}

// GetMembersByTeamIdWithResponse request returning *GetMembersByTeamIdResponse
func (c *ClientWithResponses) GetMembersByTeamIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMembersByTeamIdResponse, error) {
	rsp, err := c.GetMembersByTeamId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMembersByTeamIdResponse(rsp)
}

// VersionWithResponse request returning *VersionResponse
func (c *ClientWithResponses) VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error) {
	rsp, err := c.Version(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionResponse(rsp)
}

// ParseListApplicationsResponse parses an HTTP response from a ListApplicationsWithResponse call
func ParseListApplicationsResponse(rsp *http.Response) (*ListApplicationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDockercomposeApplicationResponse parses an HTTP response from a CreateDockercomposeApplicationWithResponse call
func ParseCreateDockercomposeApplicationResponse(rsp *http.Response) (*CreateDockercomposeApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDockercomposeApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDockerfileApplicationResponse parses an HTTP response from a CreateDockerfileApplicationWithResponse call
func ParseCreateDockerfileApplicationResponse(rsp *http.Response) (*CreateDockerfileApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDockerfileApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDockerimageApplicationResponse parses an HTTP response from a CreateDockerimageApplicationWithResponse call
func ParseCreateDockerimageApplicationResponse(rsp *http.Response) (*CreateDockerimageApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDockerimageApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePrivateDeployKeyApplicationResponse parses an HTTP response from a CreatePrivateDeployKeyApplicationWithResponse call
func ParseCreatePrivateDeployKeyApplicationResponse(rsp *http.Response) (*CreatePrivateDeployKeyApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePrivateDeployKeyApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePrivateGithubAppApplicationResponse parses an HTTP response from a CreatePrivateGithubAppApplicationWithResponse call
func ParseCreatePrivateGithubAppApplicationResponse(rsp *http.Response) (*CreatePrivateGithubAppApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePrivateGithubAppApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePublicApplicationResponse parses an HTTP response from a CreatePublicApplicationWithResponse call
func ParseCreatePublicApplicationResponse(rsp *http.Response) (*CreatePublicApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteApplicationByUuidResponse parses an HTTP response from a DeleteApplicationByUuidWithResponse call
func ParseDeleteApplicationByUuidResponse(rsp *http.Response) (*DeleteApplicationByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApplicationByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetApplicationByUuidResponse parses an HTTP response from a GetApplicationByUuidWithResponse call
func ParseGetApplicationByUuidResponse(rsp *http.Response) (*GetApplicationByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateApplicationByUuidResponse parses an HTTP response from a UpdateApplicationByUuidWithResponse call
func ParseUpdateApplicationByUuidResponse(rsp *http.Response) (*UpdateApplicationByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateApplicationByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListEnvsByApplicationUuidResponse parses an HTTP response from a ListEnvsByApplicationUuidWithResponse call
func ParseListEnvsByApplicationUuidResponse(rsp *http.Response) (*ListEnvsByApplicationUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnvsByApplicationUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnvironmentVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateEnvByApplicationUuidResponse parses an HTTP response from a UpdateEnvByApplicationUuidWithResponse call
func ParseUpdateEnvByApplicationUuidResponse(rsp *http.Response) (*UpdateEnvByApplicationUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvByApplicationUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateEnvByApplicationUuidResponse parses an HTTP response from a CreateEnvByApplicationUuidWithResponse call
func ParseCreateEnvByApplicationUuidResponse(rsp *http.Response) (*CreateEnvByApplicationUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvByApplicationUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateEnvsByApplicationUuidResponse parses an HTTP response from a UpdateEnvsByApplicationUuidWithResponse call
func ParseUpdateEnvsByApplicationUuidResponse(rsp *http.Response) (*UpdateEnvsByApplicationUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvsByApplicationUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []EnvironmentVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteEnvByApplicationUuidResponse parses an HTTP response from a DeleteEnvByApplicationUuidWithResponse call
func ParseDeleteEnvByApplicationUuidResponse(rsp *http.Response) (*DeleteEnvByApplicationUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvByApplicationUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseExecuteCommandApplicationResponse parses an HTTP response from a ExecuteCommandApplicationWithResponse call
func ParseExecuteCommandApplicationResponse(rsp *http.Response) (*ExecuteCommandApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteCommandApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message  *string `json:"message,omitempty"`
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestartApplicationByUuidResponse parses an HTTP response from a RestartApplicationByUuidWithResponse call
func ParseRestartApplicationByUuidResponse(rsp *http.Response) (*RestartApplicationByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartApplicationByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeploymentUuid UUID of the deployment.
			DeploymentUuid *string `json:"deployment_uuid,omitempty"`
			Message        *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartApplicationByUuidResponse parses an HTTP response from a StartApplicationByUuidWithResponse call
func ParseStartApplicationByUuidResponse(rsp *http.Response) (*StartApplicationByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartApplicationByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeploymentUuid UUID of the deployment.
			DeploymentUuid *string `json:"deployment_uuid,omitempty"`

			// Message Message.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopApplicationByUuidResponse parses an HTTP response from a StopApplicationByUuidWithResponse call
func ParseStopApplicationByUuidResponse(rsp *http.Response) (*StopApplicationByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopApplicationByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListDatabasesResponse parses an HTTP response from a ListDatabasesWithResponse call
func ParseListDatabasesResponse(rsp *http.Response) (*ListDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseClickhouseResponse parses an HTTP response from a CreateDatabaseClickhouseWithResponse call
func ParseCreateDatabaseClickhouseResponse(rsp *http.Response) (*CreateDatabaseClickhouseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseClickhouseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseDragonflyResponse parses an HTTP response from a CreateDatabaseDragonflyWithResponse call
func ParseCreateDatabaseDragonflyResponse(rsp *http.Response) (*CreateDatabaseDragonflyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseDragonflyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseKeydbResponse parses an HTTP response from a CreateDatabaseKeydbWithResponse call
func ParseCreateDatabaseKeydbResponse(rsp *http.Response) (*CreateDatabaseKeydbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseKeydbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseMariadbResponse parses an HTTP response from a CreateDatabaseMariadbWithResponse call
func ParseCreateDatabaseMariadbResponse(rsp *http.Response) (*CreateDatabaseMariadbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseMariadbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseMongodbResponse parses an HTTP response from a CreateDatabaseMongodbWithResponse call
func ParseCreateDatabaseMongodbResponse(rsp *http.Response) (*CreateDatabaseMongodbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseMongodbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseMysqlResponse parses an HTTP response from a CreateDatabaseMysqlWithResponse call
func ParseCreateDatabaseMysqlResponse(rsp *http.Response) (*CreateDatabaseMysqlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseMysqlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			InternalDbUrl string `json:"internal_db_url"`
			Uuid          string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabasePostgresqlResponse parses an HTTP response from a CreateDatabasePostgresqlWithResponse call
func ParseCreateDatabasePostgresqlResponse(rsp *http.Response) (*CreateDatabasePostgresqlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabasePostgresqlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			InternalDbUrl string `json:"internal_db_url"`
			Uuid          string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseRedisResponse parses an HTTP response from a CreateDatabaseRedisWithResponse call
func ParseCreateDatabaseRedisResponse(rsp *http.Response) (*CreateDatabaseRedisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseRedisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteDatabaseByUuidResponse parses an HTTP response from a DeleteDatabaseByUuidWithResponse call
func ParseDeleteDatabaseByUuidResponse(rsp *http.Response) (*DeleteDatabaseByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabaseByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDatabaseByUuidResponse parses an HTTP response from a GetDatabaseByUuidWithResponse call
func ParseGetDatabaseByUuidResponse(rsp *http.Response) (*GetDatabaseByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDatabaseByUuidResponse parses an HTTP response from a UpdateDatabaseByUuidWithResponse call
func ParseUpdateDatabaseByUuidResponse(rsp *http.Response) (*UpdateDatabaseByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatabaseByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestartDatabaseByUuidResponse parses an HTTP response from a RestartDatabaseByUuidWithResponse call
func ParseRestartDatabaseByUuidResponse(rsp *http.Response) (*RestartDatabaseByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartDatabaseByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartDatabaseByUuidResponse parses an HTTP response from a StartDatabaseByUuidWithResponse call
func ParseStartDatabaseByUuidResponse(rsp *http.Response) (*StartDatabaseByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartDatabaseByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopDatabaseByUuidResponse parses an HTTP response from a StopDatabaseByUuidWithResponse call
func ParseStopDatabaseByUuidResponse(rsp *http.Response) (*StopDatabaseByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopDatabaseByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeployByTagOrUuidResponse parses an HTTP response from a DeployByTagOrUuidWithResponse call
func ParseDeployByTagOrUuidResponse(rsp *http.Response) (*DeployByTagOrUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployByTagOrUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Deployments *[]struct {
				DeploymentUuid *string `json:"deployment_uuid,omitempty"`
				Message        *string `json:"message,omitempty"`
				ResourceUuid   *string `json:"resource_uuid,omitempty"`
			} `json:"deployments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListDeploymentsResponse parses an HTTP response from a ListDeploymentsWithResponse call
func ParseListDeploymentsResponse(rsp *http.Response) (*ListDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApplicationDeploymentQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDeploymentByUuidResponse parses an HTTP response from a GetDeploymentByUuidWithResponse call
func ParseGetDeploymentByUuidResponse(rsp *http.Response) (*GetDeploymentByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationDeploymentQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDisableApiResponse parses an HTTP response from a DisableApiWithResponse call
func ParseDisableApiResponse(rsp *http.Response) (*DisableApiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableApiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEnableApiResponse parses an HTTP response from a EnableApiWithResponse call
func ParseEnableApiResponse(rsp *http.Response) (*EnableApiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableApiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseHealthcheckResponse parses an HTTP response from a HealthcheckWithResponse call
func ParseHealthcheckResponse(rsp *http.Response) (*HealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Uuid The UUID of the project.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteProjectByUuidResponse parses an HTTP response from a DeleteProjectByUuidWithResponse call
func ParseDeleteProjectByUuidResponse(rsp *http.Response) (*DeleteProjectByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProjectByUuidResponse parses an HTTP response from a GetProjectByUuidWithResponse call
func ParseGetProjectByUuidResponse(rsp *http.Response) (*GetProjectByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateProjectByUuidResponse parses an HTTP response from a UpdateProjectByUuidWithResponse call
func ParseUpdateProjectByUuidResponse(rsp *http.Response) (*UpdateProjectByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Description *string `json:"description,omitempty"`
			Name        *string `json:"name,omitempty"`
			Uuid        *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetEnvironmentByNameOrUuidResponse parses an HTTP response from a GetEnvironmentByNameOrUuidWithResponse call
func ParseGetEnvironmentByNameOrUuidResponse(rsp *http.Response) (*GetEnvironmentByNameOrUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentByNameOrUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListResourcesResponse parses an HTTP response from a ListResourcesWithResponse call
func ParseListResourcesResponse(rsp *http.Response) (*ListResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPrivateKeysResponse parses an HTTP response from a ListPrivateKeysWithResponse call
func ParseListPrivateKeysResponse(rsp *http.Response) (*ListPrivateKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrivateKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PrivateKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePrivateKeyResponse parses an HTTP response from a CreatePrivateKeyWithResponse call
func ParseCreatePrivateKeyResponse(rsp *http.Response) (*CreatePrivateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePrivateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePrivateKeyByUuidResponse parses an HTTP response from a DeletePrivateKeyByUuidWithResponse call
func ParseDeletePrivateKeyByUuidResponse(rsp *http.Response) (*DeletePrivateKeyByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePrivateKeyByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPrivateKeyByUuidResponse parses an HTTP response from a GetPrivateKeyByUuidWithResponse call
func ParseGetPrivateKeyByUuidResponse(rsp *http.Response) (*GetPrivateKeyByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateKeyByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatePrivateKeyResponse parses an HTTP response from a UpdatePrivateKeyWithResponse call
func ParseUpdatePrivateKeyResponse(rsp *http.Response) (*UpdatePrivateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePrivateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListServersResponse parses an HTTP response from a ListServersWithResponse call
func ParseListServersResponse(rsp *http.Response) (*ListServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateServerResponse parses an HTTP response from a CreateServerWithResponse call
func ParseCreateServerResponse(rsp *http.Response) (*CreateServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Uuid The UUID of the server.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteServerByUuidResponse parses an HTTP response from a DeleteServerByUuidWithResponse call
func ParseDeleteServerByUuidResponse(rsp *http.Response) (*DeleteServerByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetServerByUuidResponse parses an HTTP response from a GetServerByUuidWithResponse call
func ParseGetServerByUuidResponse(rsp *http.Response) (*GetServerByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateServerByUuidResponse parses an HTTP response from a UpdateServerByUuidWithResponse call
func ParseUpdateServerByUuidResponse(rsp *http.Response) (*UpdateServerByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServerByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDomainsByServerUuidResponse parses an HTTP response from a GetDomainsByServerUuidWithResponse call
func ParseGetDomainsByServerUuidResponse(rsp *http.Response) (*GetDomainsByServerUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainsByServerUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Domains *[]string `json:"domains,omitempty"`
			Ip      *string   `json:"ip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetResourcesByServerUuidResponse parses an HTTP response from a GetResourcesByServerUuidWithResponse call
func ParseGetResourcesByServerUuidResponse(rsp *http.Response) (*GetResourcesByServerUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesByServerUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CreatedAt *string `json:"created_at,omitempty"`
			Id        *int    `json:"id,omitempty"`
			Name      *string `json:"name,omitempty"`
			Status    *string `json:"status,omitempty"`
			Type      *string `json:"type,omitempty"`
			UpdatedAt *string `json:"updated_at,omitempty"`
			Uuid      *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseValidateServerByUuidResponse parses an HTTP response from a ValidateServerByUuidWithResponse call
func ParseValidateServerByUuidResponse(rsp *http.Response) (*ValidateServerByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateServerByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListServicesResponse parses an HTTP response from a ListServicesWithResponse call
func ParseListServicesResponse(rsp *http.Response) (*ListServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateServiceResponse parses an HTTP response from a CreateServiceWithResponse call
func ParseCreateServiceResponse(rsp *http.Response) (*CreateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Domains Service domains.
			Domains *[]string `json:"domains,omitempty"`

			// Uuid Service UUID.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteServiceByUuidResponse parses an HTTP response from a DeleteServiceByUuidWithResponse call
func ParseDeleteServiceByUuidResponse(rsp *http.Response) (*DeleteServiceByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetServiceByUuidResponse parses an HTTP response from a GetServiceByUuidWithResponse call
func ParseGetServiceByUuidResponse(rsp *http.Response) (*GetServiceByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListEnvsByServiceUuidResponse parses an HTTP response from a ListEnvsByServiceUuidWithResponse call
func ParseListEnvsByServiceUuidResponse(rsp *http.Response) (*ListEnvsByServiceUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnvsByServiceUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnvironmentVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateEnvByServiceUuidResponse parses an HTTP response from a UpdateEnvByServiceUuidWithResponse call
func ParseUpdateEnvByServiceUuidResponse(rsp *http.Response) (*UpdateEnvByServiceUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvByServiceUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateEnvByServiceUuidResponse parses an HTTP response from a CreateEnvByServiceUuidWithResponse call
func ParseCreateEnvByServiceUuidResponse(rsp *http.Response) (*CreateEnvByServiceUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvByServiceUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateEnvsByServiceUuidResponse parses an HTTP response from a UpdateEnvsByServiceUuidWithResponse call
func ParseUpdateEnvsByServiceUuidResponse(rsp *http.Response) (*UpdateEnvsByServiceUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvsByServiceUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []EnvironmentVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteEnvByServiceUuidResponse parses an HTTP response from a DeleteEnvByServiceUuidWithResponse call
func ParseDeleteEnvByServiceUuidResponse(rsp *http.Response) (*DeleteEnvByServiceUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvByServiceUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestartServiceByUuidResponse parses an HTTP response from a RestartServiceByUuidWithResponse call
func ParseRestartServiceByUuidResponse(rsp *http.Response) (*RestartServiceByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartServiceByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartServiceByUuidResponse parses an HTTP response from a StartServiceByUuidWithResponse call
func ParseStartServiceByUuidResponse(rsp *http.Response) (*StartServiceByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartServiceByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopServiceByUuidResponse parses an HTTP response from a StopServiceByUuidWithResponse call
func ParseStopServiceByUuidResponse(rsp *http.Response) (*StopServiceByUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopServiceByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCurrentTeamResponse parses an HTTP response from a GetCurrentTeamWithResponse call
func ParseGetCurrentTeamResponse(rsp *http.Response) (*GetCurrentTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCurrentTeamMembersResponse parses an HTTP response from a GetCurrentTeamMembersWithResponse call
func ParseGetCurrentTeamMembersResponse(rsp *http.Response) (*GetCurrentTeamMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentTeamMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTeamByIdResponse parses an HTTP response from a GetTeamByIdWithResponse call
func ParseGetTeamByIdResponse(rsp *http.Response) (*GetTeamByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMembersByTeamIdResponse parses an HTTP response from a GetMembersByTeamIdWithResponse call
func ParseGetMembersByTeamIdResponse(rsp *http.Response) (*GetMembersByTeamIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMembersByTeamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseVersionResponse parses an HTTP response from a VersionWithResponse call
func ParseVersionResponse(rsp *http.Response) (*VersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
